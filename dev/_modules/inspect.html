
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>inspect &#8212; MetPy 1.0dev</title>
    
  <link rel="stylesheet" href="../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
<style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,400;0,600;0,700;1,400;1,600;1,700&display=swap');
</style>
    
      
  <link rel="stylesheet"
    href="../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../_static/vendor/lato_latin-ext/1.44.1/index.css">

    

    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../_static/theme-unidata.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/doc_shared.js"></script>
    <link rel="shortcut icon" href="../_static/metpy_32x32.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    <link rel="canonical" href="https://unidata.github.io/MetPy/latest/_modules/inspect.html" />

  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
  <nav class="navbar navbar-dark navbar-expand-lg bg-unidata fixed-top bd-navbar shadow" id="navbar-main"><div class="container-xl">

    <a class="navbar-brand" href="../index.html">
    
      <img src="../_static/metpy_horizontal.png" class="logo" alt="logo" />
    
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-menu" aria-controls="navbar-menu" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>


    <div id="navbar-menu" class="collapse navbar-collapse">
      <ul id="navbar-main-elements" class="navbar-nav mr-auto">


        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            Version 1.0dev
          </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdown" id="version-menu"></div>
        </li>


        
        
        <li class="nav-item ">
            <a class="nav-link" href="../userguide/index.html">User Guide</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../api/index.html">Reference Guide</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../devel/index.html">Developerâ€™s Guide</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../examples/index.html">Example Gallery</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../userguide/SUPPORT.html">Support</a>
        </li>
        
        
        <li class="nav-item">
            <a class="nav-link nav-external" href="https://github.com/Unidata/MetPy/releases">Release Notes<i class="fas fa-external-link-alt"></i></a>
        </li>
        
      </ul>


      <form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
      

      <ul class="navbar-nav">
        
          <li class="nav-item">
            <a class="nav-link" href="https://github.com/Unidata/MetPy" target="_blank" rel="noopener">
              <span><i class="fab fa-github-square"></i></span>
            </a>
          </li>
        
        
          <li class="nav-item">
            <a class="nav-link" href="https://twitter.com/MetPy" target="_blank" rel="noopener">
              <span><i class="fab fa-twitter-square"></i></span>
            </a>
          </li>
        
      </ul>
    </div>
</div>
  </nav>


    <div class="container-fluid" id="banner"></div>


    <div class="container-xl">
      <div class="row">
          
          <div class="col-12 col-md-3 bd-sidebar"><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">

    <div class="bd-toc-item active">
    
  
    <ul class="nav bd-sidenav">
        
        
        
        
        
        
        
        
        
        
        
      </ul>
  
  </nav>
          </div>
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
              

<nav id="bd-toc-nav">
    <ul class="nav section-nav flex-column">
    
    </ul>
</nav>


              
          </div>
          

          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for inspect</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Get useful information from live Python objects.</span>

<span class="sd">This module encapsulates the interface provided by the internal special</span>
<span class="sd">attributes (co_*, im_*, tb_*, etc.) in a friendlier fashion.</span>
<span class="sd">It also provides some help for examining source code and class layout.</span>

<span class="sd">Here are some of the useful functions provided by this module:</span>

<span class="sd">    ismodule(), isclass(), ismethod(), isfunction(), isgeneratorfunction(),</span>
<span class="sd">        isgenerator(), istraceback(), isframe(), iscode(), isbuiltin(),</span>
<span class="sd">        isroutine() - check object types</span>
<span class="sd">    getmembers() - get members of an object that satisfy a given condition</span>

<span class="sd">    getfile(), getsourcefile(), getsource() - find an object&#39;s source code</span>
<span class="sd">    getdoc(), getcomments() - get documentation on an object</span>
<span class="sd">    getmodule() - determine the module that an object came from</span>
<span class="sd">    getclasstree() - arrange classes so as to represent their hierarchy</span>

<span class="sd">    getargvalues(), getcallargs() - get info about function arguments</span>
<span class="sd">    getfullargspec() - same, with support for Python 3 features</span>
<span class="sd">    formatargvalues() - format an argument spec</span>
<span class="sd">    getouterframes(), getinnerframes() - get info about frames</span>
<span class="sd">    currentframe() - get the current stack frame</span>
<span class="sd">    stack(), trace() - get info about frames on the stack or in a traceback</span>

<span class="sd">    signature() - get a Signature object for the callable</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># This module is in the public domain.  No warranties.</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Ka-Ping Yee &lt;ping@lfw.org&gt;&#39;</span><span class="p">,</span>
              <span class="s1">&#39;Yury Selivanov &lt;yselivanov@sprymix.com&gt;&#39;</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">dis</span>
<span class="kn">import</span> <span class="nn">collections.abc</span>
<span class="kn">import</span> <span class="nn">enum</span>
<span class="kn">import</span> <span class="nn">importlib.machinery</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">linecache</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">tokenize</span>
<span class="kn">import</span> <span class="nn">token</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">builtins</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">attrgetter</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span><span class="p">,</span> <span class="n">OrderedDict</span>

<span class="c1"># Create constants for the compiler flags in Include/code.h</span>
<span class="c1"># We try to get them from dis to avoid duplication</span>
<span class="n">mod_dict</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()</span>
<span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dis</span><span class="o">.</span><span class="n">COMPILER_FLAG_NAMES</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">mod_dict</span><span class="p">[</span><span class="s2">&quot;CO_&quot;</span> <span class="o">+</span> <span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>

<span class="c1"># See Include/object.h</span>
<span class="n">TPFLAGS_IS_ABSTRACT</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span>

<span class="c1"># ----------------------------------------------------------- type-checking</span>
<span class="k">def</span> <span class="nf">ismodule</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return true if the object is a module.</span>

<span class="sd">    Module objects provide these attributes:</span>
<span class="sd">        __cached__      pathname to byte compiled file</span>
<span class="sd">        __doc__         documentation string</span>
<span class="sd">        __file__        filename (missing for built-in modules)&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">isclass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return true if the object is a class.</span>

<span class="sd">    Class objects provide these attributes:</span>
<span class="sd">        __doc__         documentation string</span>
<span class="sd">        __module__      name of module in which this class was defined&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">ismethod</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return true if the object is an instance method.</span>

<span class="sd">    Instance method objects provide these attributes:</span>
<span class="sd">        __doc__         documentation string</span>
<span class="sd">        __name__        name with which this method was defined</span>
<span class="sd">        __func__        function object containing implementation of method</span>
<span class="sd">        __self__        instance to which this method is bound&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">ismethoddescriptor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return true if the object is a method descriptor.</span>

<span class="sd">    But not if ismethod() or isclass() or isfunction() are true.</span>

<span class="sd">    This is new in Python 2.2, and, for example, is true of int.__add__.</span>
<span class="sd">    An object passing this test has a __get__ attribute but not a __set__</span>
<span class="sd">    attribute, but beyond that the set of attributes varies.  __name__ is</span>
<span class="sd">    usually sensible, and __doc__ often is.</span>

<span class="sd">    Methods implemented via descriptors that also pass one of the other</span>
<span class="sd">    tests return false from the ismethoddescriptor() test, simply because</span>
<span class="sd">    the other tests promise more -- you can, e.g., count on having the</span>
<span class="sd">    __func__ attribute (etc) when an object passes ismethod().&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">isclass</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span> <span class="ow">or</span> <span class="n">ismethod</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span> <span class="ow">or</span> <span class="n">isfunction</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="c1"># mutual exclusion</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">tp</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="s2">&quot;__get__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="s2">&quot;__set__&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">isdatadescriptor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return true if the object is a data descriptor.</span>

<span class="sd">    Data descriptors have a __set__ or a __delete__ attribute.  Examples are</span>
<span class="sd">    properties (defined in Python) and getsets and members (defined in C).</span>
<span class="sd">    Typically, data descriptors will also have __name__ and __doc__ attributes</span>
<span class="sd">    (properties, getsets, and members have both of these attributes), but this</span>
<span class="sd">    is not guaranteed.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">isclass</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span> <span class="ow">or</span> <span class="n">ismethod</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span> <span class="ow">or</span> <span class="n">isfunction</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="c1"># mutual exclusion</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">tp</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="s2">&quot;__set__&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="s2">&quot;__delete__&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">types</span><span class="p">,</span> <span class="s1">&#39;MemberDescriptorType&#39;</span><span class="p">):</span>
    <span class="c1"># CPython and equivalent</span>
    <span class="k">def</span> <span class="nf">ismemberdescriptor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return true if the object is a member descriptor.</span>

<span class="sd">        Member descriptors are specialized descriptors defined in extension</span>
<span class="sd">        modules.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MemberDescriptorType</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># Other implementations</span>
    <span class="k">def</span> <span class="nf">ismemberdescriptor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return true if the object is a member descriptor.</span>

<span class="sd">        Member descriptors are specialized descriptors defined in extension</span>
<span class="sd">        modules.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">types</span><span class="p">,</span> <span class="s1">&#39;GetSetDescriptorType&#39;</span><span class="p">):</span>
    <span class="c1"># CPython and equivalent</span>
    <span class="k">def</span> <span class="nf">isgetsetdescriptor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return true if the object is a getset descriptor.</span>

<span class="sd">        getset descriptors are specialized descriptors defined in extension</span>
<span class="sd">        modules.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GetSetDescriptorType</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># Other implementations</span>
    <span class="k">def</span> <span class="nf">isgetsetdescriptor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return true if the object is a getset descriptor.</span>

<span class="sd">        getset descriptors are specialized descriptors defined in extension</span>
<span class="sd">        modules.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">isfunction</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return true if the object is a user-defined function.</span>

<span class="sd">    Function objects provide these attributes:</span>
<span class="sd">        __doc__         documentation string</span>
<span class="sd">        __name__        name with which this function was defined</span>
<span class="sd">        __code__        code object containing compiled function bytecode</span>
<span class="sd">        __defaults__    tuple of any default values for arguments</span>
<span class="sd">        __globals__     global namespace in which this function was defined</span>
<span class="sd">        __annotations__ dict of parameter annotations</span>
<span class="sd">        __kwdefaults__  dict of keyword only parameters with defaults&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_has_code_flag</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return true if ``f`` is a function (or a method or functools.partial</span>
<span class="sd">    wrapper wrapping a function) whose code object has the given ``flag``</span>
<span class="sd">    set in its flags.&quot;&quot;&quot;</span>
    <span class="k">while</span> <span class="n">ismethod</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="vm">__func__</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">_unwrap_partial</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isfunction</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="vm">__code__</span><span class="o">.</span><span class="n">co_flags</span> <span class="o">&amp;</span> <span class="n">flag</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">isgeneratorfunction</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return true if the object is a user-defined generator function.</span>

<span class="sd">    Generator function objects provide the same attributes as functions.</span>
<span class="sd">    See help(isfunction) for a list of attributes.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_has_code_flag</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">CO_GENERATOR</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">iscoroutinefunction</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return true if the object is a coroutine function.</span>

<span class="sd">    Coroutine functions are defined with &quot;async def&quot; syntax.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_has_code_flag</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">CO_COROUTINE</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">isasyncgenfunction</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return true if the object is an asynchronous generator function.</span>

<span class="sd">    Asynchronous generator functions are defined with &quot;async def&quot;</span>
<span class="sd">    syntax and have &quot;yield&quot; expressions in their body.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_has_code_flag</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">CO_ASYNC_GENERATOR</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">isasyncgen</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return true if the object is an asynchronous generator.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">AsyncGeneratorType</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">isgenerator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return true if the object is a generator.</span>

<span class="sd">    Generator objects provide these attributes:</span>
<span class="sd">        __iter__        defined to support iteration over container</span>
<span class="sd">        close           raises a new GeneratorExit exception inside the</span>
<span class="sd">                        generator to terminate the iteration</span>
<span class="sd">        gi_code         code object</span>
<span class="sd">        gi_frame        frame object or possibly None once the generator has</span>
<span class="sd">                        been exhausted</span>
<span class="sd">        gi_running      set to 1 when generator is executing, 0 otherwise</span>
<span class="sd">        next            return the next item from the container</span>
<span class="sd">        send            resumes the generator and &quot;sends&quot; a value that becomes</span>
<span class="sd">                        the result of the current yield-expression</span>
<span class="sd">        throw           used to raise an exception inside the generator&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">iscoroutine</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return true if the object is a coroutine.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">CoroutineType</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">isawaitable</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return true if object can be passed to an ``await`` expression.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">CoroutineType</span><span class="p">)</span> <span class="ow">or</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span><span class="p">)</span> <span class="ow">and</span>
                <span class="nb">bool</span><span class="p">(</span><span class="nb">object</span><span class="o">.</span><span class="n">gi_code</span><span class="o">.</span><span class="n">co_flags</span> <span class="o">&amp;</span> <span class="n">CO_ITERABLE_COROUTINE</span><span class="p">)</span> <span class="ow">or</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Awaitable</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">istraceback</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return true if the object is a traceback.</span>

<span class="sd">    Traceback objects provide these attributes:</span>
<span class="sd">        tb_frame        frame object at this level</span>
<span class="sd">        tb_lasti        index of last attempted instruction in bytecode</span>
<span class="sd">        tb_lineno       current line number in Python source code</span>
<span class="sd">        tb_next         next inner traceback object (called by this level)&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">TracebackType</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">isframe</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return true if the object is a frame object.</span>

<span class="sd">    Frame objects provide these attributes:</span>
<span class="sd">        f_back          next outer frame object (this frame&#39;s caller)</span>
<span class="sd">        f_builtins      built-in namespace seen by this frame</span>
<span class="sd">        f_code          code object being executed in this frame</span>
<span class="sd">        f_globals       global namespace seen by this frame</span>
<span class="sd">        f_lasti         index of last attempted instruction in bytecode</span>
<span class="sd">        f_lineno        current line number in Python source code</span>
<span class="sd">        f_locals        local namespace seen by this frame</span>
<span class="sd">        f_trace         tracing function for this frame, or None&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">FrameType</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">iscode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return true if the object is a code object.</span>

<span class="sd">    Code objects provide these attributes:</span>
<span class="sd">        co_argcount         number of arguments (not including *, ** args</span>
<span class="sd">                            or keyword only arguments)</span>
<span class="sd">        co_code             string of raw compiled bytecode</span>
<span class="sd">        co_cellvars         tuple of names of cell variables</span>
<span class="sd">        co_consts           tuple of constants used in the bytecode</span>
<span class="sd">        co_filename         name of file in which this code object was created</span>
<span class="sd">        co_firstlineno      number of first line in Python source code</span>
<span class="sd">        co_flags            bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg</span>
<span class="sd">                            | 16=nested | 32=generator | 64=nofree | 128=coroutine</span>
<span class="sd">                            | 256=iterable_coroutine | 512=async_generator</span>
<span class="sd">        co_freevars         tuple of names of free variables</span>
<span class="sd">        co_posonlyargcount  number of positional only arguments</span>
<span class="sd">        co_kwonlyargcount   number of keyword only arguments (not including ** arg)</span>
<span class="sd">        co_lnotab           encoded mapping of line numbers to bytecode indices</span>
<span class="sd">        co_name             name with which this code object was defined</span>
<span class="sd">        co_names            tuple of names of local variables</span>
<span class="sd">        co_nlocals          number of local variables</span>
<span class="sd">        co_stacksize        virtual machine stack space required</span>
<span class="sd">        co_varnames         tuple of names of arguments and local variables&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">CodeType</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">isbuiltin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return true if the object is a built-in function or method.</span>

<span class="sd">    Built-in functions and methods provide these attributes:</span>
<span class="sd">        __doc__         documentation string</span>
<span class="sd">        __name__        original name of this function or method</span>
<span class="sd">        __self__        instance to which a method is bound, or None&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">BuiltinFunctionType</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">isroutine</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return true if the object is any kind of function or method.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">isbuiltin</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">isfunction</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">ismethod</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">ismethoddescriptor</span><span class="p">(</span><span class="nb">object</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">isabstract</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return true if the object is an abstract base class (ABC).&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">object</span><span class="o">.</span><span class="n">__flags__</span> <span class="o">&amp;</span> <span class="n">TPFLAGS_IS_ABSTRACT</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="nb">object</span><span class="p">),</span> <span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="s1">&#39;__abstractmethods__&#39;</span><span class="p">):</span>
        <span class="c1"># It looks like ABCMeta.__new__ has finished running;</span>
        <span class="c1"># TPFLAGS_IS_ABSTRACT should have been accurate.</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="c1"># It looks like ABCMeta.__new__ has not finished running yet; we&#39;re</span>
    <span class="c1"># probably in __init_subclass__. We&#39;ll look for abstractmethods manually.</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">object</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;__isabstractmethod__&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">object</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s2">&quot;__abstractmethods__&quot;</span><span class="p">,</span> <span class="p">()):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;__isabstractmethod__&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">getmembers</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return all members of an object as (name, value) pairs sorted by name.</span>
<span class="sd">    Optionally, only return members that satisfy a given predicate.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">isclass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="n">mro</span> <span class="o">=</span> <span class="p">(</span><span class="nb">object</span><span class="p">,)</span> <span class="o">+</span> <span class="n">getmro</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mro</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">processed</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">names</span> <span class="o">=</span> <span class="nb">dir</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
    <span class="c1"># :dd any DynamicClassAttributes to the list of names if object is a class;</span>
    <span class="c1"># this may result in duplicate entries if, for example, a virtual</span>
    <span class="c1"># attribute with the same name as a DynamicClassAttribute exists</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">object</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">DynamicClassAttribute</span><span class="p">):</span>
                    <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
        <span class="c1"># First try to get the value via getattr.  Some descriptors don&#39;t</span>
        <span class="c1"># like calling their __get__ (see bug #1785), so fall back to</span>
        <span class="c1"># looking in the __dict__.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="c1"># handle the duplicate key</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">processed</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">mro</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># could be a (currently) missing slot member, or a buggy</span>
                <span class="c1"># __dir__; discard and move on</span>
                <span class="k">continue</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">predicate</span> <span class="ow">or</span> <span class="n">predicate</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
        <span class="n">processed</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="n">results</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">results</span>

<span class="n">Attribute</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Attribute&#39;</span><span class="p">,</span> <span class="s1">&#39;name kind defining_class object&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">classify_class_attrs</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return list of attribute-descriptor tuples.</span>

<span class="sd">    For each name in dir(cls), the return list contains a 4-tuple</span>
<span class="sd">    with these elements:</span>

<span class="sd">        0. The name (a string).</span>

<span class="sd">        1. The kind of attribute this is, one of these strings:</span>
<span class="sd">               &#39;class method&#39;    created via classmethod()</span>
<span class="sd">               &#39;static method&#39;   created via staticmethod()</span>
<span class="sd">               &#39;property&#39;        created via property()</span>
<span class="sd">               &#39;method&#39;          any other flavor of method or descriptor</span>
<span class="sd">               &#39;data&#39;            not a method</span>

<span class="sd">        2. The class which defined this attribute (a class).</span>

<span class="sd">        3. The object as obtained by calling getattr; if this fails, or if the</span>
<span class="sd">           resulting object does not live anywhere in the class&#39; mro (including</span>
<span class="sd">           metaclasses) then the object is looked up in the defining class&#39;s</span>
<span class="sd">           dict (found by walking the mro).</span>

<span class="sd">    If one of the items in dir(cls) is stored in the metaclass it will now</span>
<span class="sd">    be discovered and not have None be listed as the class in which it was</span>
<span class="sd">    defined.  Any items whose home class cannot be discovered are skipped.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mro</span> <span class="o">=</span> <span class="n">getmro</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
    <span class="n">metamro</span> <span class="o">=</span> <span class="n">getmro</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">cls</span><span class="p">))</span> <span class="c1"># for attributes stored in the metaclass</span>
    <span class="n">metamro</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">cls</span> <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">metamro</span> <span class="k">if</span> <span class="bp">cls</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="nb">object</span><span class="p">))</span>
    <span class="n">class_bases</span> <span class="o">=</span> <span class="p">(</span><span class="bp">cls</span><span class="p">,)</span> <span class="o">+</span> <span class="n">mro</span>
    <span class="n">all_bases</span> <span class="o">=</span> <span class="n">class_bases</span> <span class="o">+</span> <span class="n">metamro</span>
    <span class="n">names</span> <span class="o">=</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
    <span class="c1"># :dd any DynamicClassAttributes to the list of names;</span>
    <span class="c1"># this may result in duplicate entries if, for example, a virtual</span>
    <span class="c1"># attribute with the same name as a DynamicClassAttribute exists.</span>
    <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">mro</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">DynamicClassAttribute</span><span class="p">):</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">processed</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
        <span class="c1"># Get the object associated with the name, and where it was defined.</span>
        <span class="c1"># Normal objects will be looked up with both getattr and directly in</span>
        <span class="c1"># its class&#39; dict (in case getattr fails [bug #1785], and also to look</span>
        <span class="c1"># for a docstring).</span>
        <span class="c1"># For DynamicClassAttributes on the second pass we only look in the</span>
        <span class="c1"># class&#39;s dict.</span>
        <span class="c1">#</span>
        <span class="c1"># Getting an obj from the __dict__ sometimes reveals more than</span>
        <span class="c1"># using getattr.  Static and class methods are dramatic examples.</span>
        <span class="n">homecls</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">get_obj</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">dict_obj</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">processed</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;__dict__&#39;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;__dict__ is special, don&#39;t want the proxy&quot;</span><span class="p">)</span>
                <span class="n">get_obj</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">homecls</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">get_obj</span><span class="p">,</span> <span class="s2">&quot;__objclass__&quot;</span><span class="p">,</span> <span class="n">homecls</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">homecls</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">class_bases</span><span class="p">:</span>
                    <span class="c1"># if the resulting object does not live somewhere in the</span>
                    <span class="c1"># mro, drop it and search the mro manually</span>
                    <span class="n">homecls</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">last_cls</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="c1"># first look in the classes</span>
                    <span class="k">for</span> <span class="n">srch_cls</span> <span class="ow">in</span> <span class="n">class_bases</span><span class="p">:</span>
                        <span class="n">srch_obj</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">srch_cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">srch_obj</span> <span class="ow">is</span> <span class="n">get_obj</span><span class="p">:</span>
                            <span class="n">last_cls</span> <span class="o">=</span> <span class="n">srch_cls</span>
                    <span class="c1"># then check the metaclasses</span>
                    <span class="k">for</span> <span class="n">srch_cls</span> <span class="ow">in</span> <span class="n">metamro</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">srch_obj</span> <span class="o">=</span> <span class="n">srch_cls</span><span class="o">.</span><span class="fm">__getattr__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">srch_obj</span> <span class="ow">is</span> <span class="n">get_obj</span><span class="p">:</span>
                            <span class="n">last_cls</span> <span class="o">=</span> <span class="n">srch_cls</span>
                    <span class="k">if</span> <span class="n">last_cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">homecls</span> <span class="o">=</span> <span class="n">last_cls</span>
        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">all_bases</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
                <span class="n">dict_obj</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">homecls</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">metamro</span><span class="p">:</span>
                    <span class="n">homecls</span> <span class="o">=</span> <span class="n">base</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">homecls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># unable to locate the attribute anywhere, most likely due to</span>
            <span class="c1"># buggy custom __dir__; discard and move on</span>
            <span class="k">continue</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">get_obj</span> <span class="k">if</span> <span class="n">get_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dict_obj</span>
        <span class="c1"># Classify the object or its descriptor.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dict_obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">staticmethod</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">BuiltinMethodType</span><span class="p">)):</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="s2">&quot;static method&quot;</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">dict_obj</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dict_obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">classmethod</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">ClassMethodDescriptorType</span><span class="p">)):</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="s2">&quot;class method&quot;</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">dict_obj</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dict_obj</span><span class="p">,</span> <span class="nb">property</span><span class="p">):</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="s2">&quot;property&quot;</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">dict_obj</span>
        <span class="k">elif</span> <span class="n">isroutine</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="s2">&quot;method&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="s2">&quot;data&quot;</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Attribute</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">homecls</span><span class="p">,</span> <span class="n">obj</span><span class="p">))</span>
        <span class="n">processed</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="c1"># ----------------------------------------------------------- class helpers</span>

<span class="k">def</span> <span class="nf">getmro</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="s2">&quot;Return tuple of base classes (including cls) in method resolution order.&quot;</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__mro__</span>

<span class="c1"># -------------------------------------------------------- function helpers</span>

<span class="k">def</span> <span class="nf">unwrap</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the object wrapped by *func*.</span>

<span class="sd">   Follows the chain of :attr:`__wrapped__` attributes returning the last</span>
<span class="sd">   object in the chain.</span>

<span class="sd">   *stop* is an optional callback accepting an object in the wrapper chain</span>
<span class="sd">   as its sole argument that allows the unwrapping to be terminated early if</span>
<span class="sd">   the callback returns a true value. If the callback never returns a true</span>
<span class="sd">   value, the last object in the chain is returned as usual. For example,</span>
<span class="sd">   :func:`signature` uses this to stop unwrapping if any object in the</span>
<span class="sd">   chain has a ``__signature__`` attribute defined.</span>

<span class="sd">   :exc:`ValueError` is raised if a cycle is encountered.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">_is_wrapper</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;__wrapped__&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">_is_wrapper</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;__wrapped__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">stop</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span>  <span class="c1"># remember the original func for error reporting</span>
    <span class="c1"># Memoise by id to tolerate non-hashable objects, but store objects to</span>
    <span class="c1"># ensure they aren&#39;t destroyed, which would allow their IDs to be reused.</span>
    <span class="n">memo</span> <span class="o">=</span> <span class="p">{</span><span class="nb">id</span><span class="p">(</span><span class="n">f</span><span class="p">):</span> <span class="n">f</span><span class="p">}</span>
    <span class="n">recursion_limit</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">getrecursionlimit</span><span class="p">()</span>
    <span class="k">while</span> <span class="n">_is_wrapper</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">__wrapped__</span>
        <span class="n">id_func</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">id_func</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">memo</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">recursion_limit</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;wrapper loop when unwrapping </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
        <span class="n">memo</span><span class="p">[</span><span class="n">id_func</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">func</span>

<span class="c1"># -------------------------------------------------- source code extraction</span>
<span class="k">def</span> <span class="nf">indentsize</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the indent size, in spaces, at the start of a line of text.&quot;&quot;&quot;</span>
    <span class="n">expline</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">()</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">expline</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">expline</span><span class="o">.</span><span class="n">lstrip</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">_findclass</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="bp">cls</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__module__</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">func</span><span class="o">.</span><span class="vm">__qualname__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="bp">cls</span>

<span class="k">def</span> <span class="nf">_finddoc</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">isclass</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">object</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">doc</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="vm">__doc__</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">doc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">doc</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">ismethod</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__func__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__self__</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isclass</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">and</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="s1">&#39;__func__&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__func__</span><span class="p">):</span>
            <span class="c1"># classmethod</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
    <span class="k">elif</span> <span class="n">isfunction</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="n">_findclass</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">obj</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="n">isbuiltin</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__self__</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isclass</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">==</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">):</span>
            <span class="c1"># classmethod</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
    <span class="c1"># Should be tested before isdatadescriptor().</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">property</span><span class="p">):</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">fget</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="n">_findclass</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">obj</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="n">ismethoddescriptor</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">or</span> <span class="n">isdatadescriptor</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__objclass__</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">obj</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">ismemberdescriptor</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
            <span class="n">slots</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;__slots__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slots</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">slots</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">slots</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">doc</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="vm">__doc__</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">doc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">doc</span>
    <span class="k">return</span> <span class="kc">None</span>

<span class="k">def</span> <span class="nf">getdoc</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the documentation string for an object.</span>

<span class="sd">    All tabs are expanded to spaces.  To clean up docstrings that are</span>
<span class="sd">    indented to line up with blocks of code, any whitespace than can be</span>
<span class="sd">    uniformly removed from the second line onwards is removed.&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="vm">__doc__</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">doc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">doc</span> <span class="o">=</span> <span class="n">_finddoc</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">cleandoc</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">cleandoc</span><span class="p">(</span><span class="n">doc</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Clean up indentation from docstrings.</span>

<span class="sd">    Any whitespace that can be uniformly removed from the second line</span>
<span class="sd">    onwards is removed.&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">UnicodeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Find minimum indentation of any non-blank lines after first line.</span>
        <span class="n">margin</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">content</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">lstrip</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">content</span><span class="p">:</span>
                <span class="n">indent</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">-</span> <span class="n">content</span>
                <span class="n">margin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">margin</span><span class="p">,</span> <span class="n">indent</span><span class="p">)</span>
        <span class="c1"># Remove indentation.</span>
        <span class="k">if</span> <span class="n">lines</span><span class="p">:</span>
            <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">margin</span> <span class="o">&lt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)):</span> <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">margin</span><span class="p">:]</span>
        <span class="c1"># Remove any trailing or leading blank lines.</span>
        <span class="k">while</span> <span class="n">lines</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">lines</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">getfile</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Work out which source or compiled file an object was defined in.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ismodule</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="s1">&#39;__file__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="vm">__file__</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{!r}</span><span class="s1"> is a built-in module&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">object</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">isclass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="s1">&#39;__module__&#39;</span><span class="p">):</span>
            <span class="n">module</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">object</span><span class="o">.</span><span class="vm">__module__</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="s1">&#39;__file__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">module</span><span class="o">.</span><span class="vm">__file__</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{!r}</span><span class="s1"> is a built-in class&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">object</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">ismethod</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="nb">object</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="vm">__func__</span>
    <span class="k">if</span> <span class="n">isfunction</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="nb">object</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="vm">__code__</span>
    <span class="k">if</span> <span class="n">istraceback</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="nb">object</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">tb_frame</span>
    <span class="k">if</span> <span class="n">isframe</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="nb">object</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">f_code</span>
    <span class="k">if</span> <span class="n">iscode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="n">co_filename</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;module, class, method, function, traceback, frame, or &#39;</span>
                    <span class="s1">&#39;code object was expected, got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">getmodulename</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the module name for a given file, or None.&quot;&quot;&quot;</span>
    <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="c1"># Check for paths that look like an actual module file</span>
    <span class="n">suffixes</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">suffix</span><span class="p">),</span> <span class="n">suffix</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">suffix</span> <span class="ow">in</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">all_suffixes</span><span class="p">()]</span>
    <span class="n">suffixes</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span> <span class="c1"># try longest suffixes first, in case they overlap</span>
    <span class="k">for</span> <span class="n">neglen</span><span class="p">,</span> <span class="n">suffix</span> <span class="ow">in</span> <span class="n">suffixes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fname</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">suffix</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">fname</span><span class="p">[:</span><span class="n">neglen</span><span class="p">]</span>
    <span class="k">return</span> <span class="kc">None</span>

<span class="k">def</span> <span class="nf">getsourcefile</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the filename that can be used to locate an object&#39;s source.</span>
<span class="sd">    Return None if no way can be identified to get the source.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="n">getfile</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
    <span class="n">all_bytecode_suffixes</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">DEBUG_BYTECODE_SUFFIXES</span><span class="p">[:]</span>
    <span class="n">all_bytecode_suffixes</span> <span class="o">+=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">OPTIMIZED_BYTECODE_SUFFIXES</span><span class="p">[:]</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">all_bytecode_suffixes</span><span class="p">):</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filename</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                    <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SOURCE_SUFFIXES</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span>
                 <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">EXTENSION_SUFFIXES</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">filename</span>
    <span class="c1"># only return a non-existent filename if the module has a PEP 302 loader</span>
    <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">getmodule</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">filename</span><span class="p">),</span> <span class="s1">&#39;__loader__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">filename</span>
    <span class="c1"># or it is in the linecache</span>
    <span class="k">if</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">linecache</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">filename</span>

<span class="k">def</span> <span class="nf">getabsfile</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">_filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return an absolute path to the source or compiled file for an object.</span>

<span class="sd">    The idea is for each object to have a unique origin, so this routine</span>
<span class="sd">    normalizes the result as much as possible.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">_filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_filename</span> <span class="o">=</span> <span class="n">getsourcefile</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span> <span class="ow">or</span> <span class="n">getfile</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normcase</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">_filename</span><span class="p">))</span>

<span class="n">modulesbyfile</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">_filesbymodname</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">def</span> <span class="nf">getmodule</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">_filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the module an object was defined in, or None if not found.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ismodule</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">object</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="s1">&#39;__module__&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">object</span><span class="o">.</span><span class="vm">__module__</span><span class="p">)</span>
    <span class="c1"># Try the filename to modulename cache</span>
    <span class="k">if</span> <span class="n">_filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">_filename</span> <span class="ow">in</span> <span class="n">modulesbyfile</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">modulesbyfile</span><span class="p">[</span><span class="n">_filename</span><span class="p">])</span>
    <span class="c1"># Try the cache again with the absolute file name</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">file</span> <span class="o">=</span> <span class="n">getabsfile</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">_filename</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">modulesbyfile</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">modulesbyfile</span><span class="p">[</span><span class="n">file</span><span class="p">])</span>
    <span class="c1"># Update the filename to module name cache and check yet again</span>
    <span class="c1"># Copy sys.modules in order to cope with changes while iterating</span>
    <span class="k">for</span> <span class="n">modname</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">ismodule</span><span class="p">(</span><span class="n">module</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="s1">&#39;__file__&#39;</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="vm">__file__</span>
            <span class="k">if</span> <span class="n">f</span> <span class="o">==</span> <span class="n">_filesbymodname</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">modname</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                <span class="c1"># Have already mapped this module, so skip it</span>
                <span class="k">continue</span>
            <span class="n">_filesbymodname</span><span class="p">[</span><span class="n">modname</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">getabsfile</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
            <span class="c1"># Always map to the name the module knows itself by</span>
            <span class="n">modulesbyfile</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">modulesbyfile</span><span class="p">[</span>
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">f</span><span class="p">)]</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">if</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">modulesbyfile</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">modulesbyfile</span><span class="p">[</span><span class="n">file</span><span class="p">])</span>
    <span class="c1"># Check the main module</span>
    <span class="n">main</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="s1">&#39;__main__&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">main</span><span class="p">,</span> <span class="nb">object</span><span class="o">.</span><span class="vm">__name__</span><span class="p">):</span>
        <span class="n">mainobject</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">main</span><span class="p">,</span> <span class="nb">object</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mainobject</span> <span class="ow">is</span> <span class="nb">object</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">main</span>
    <span class="c1"># Check builtins</span>
    <span class="n">builtin</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="s1">&#39;builtins&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">builtin</span><span class="p">,</span> <span class="nb">object</span><span class="o">.</span><span class="vm">__name__</span><span class="p">):</span>
        <span class="n">builtinobject</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">builtin</span><span class="p">,</span> <span class="nb">object</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">builtinobject</span> <span class="ow">is</span> <span class="nb">object</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">builtin</span>

<span class="k">def</span> <span class="nf">findsource</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the entire source file and starting line number for an object.</span>

<span class="sd">    The argument may be a module, class, method, function, traceback, frame,</span>
<span class="sd">    or code object.  The source code is returned as a list of all the lines</span>
<span class="sd">    in the file and the line number indexes a line in that list.  An OSError</span>
<span class="sd">    is raised if the source code cannot be retrieved.&quot;&quot;&quot;</span>

    <span class="n">file</span> <span class="o">=</span> <span class="n">getsourcefile</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">file</span><span class="p">:</span>
        <span class="c1"># Invalidate cache if needed.</span>
        <span class="n">linecache</span><span class="o">.</span><span class="n">checkcache</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">file</span> <span class="o">=</span> <span class="n">getfile</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
        <span class="c1"># Allow filenames in form of &quot;&lt;something&gt;&quot; to pass through.</span>
        <span class="c1"># `doctest` monkeypatches `linecache` module to enable</span>
        <span class="c1"># inspection, so let `linecache.getlines` to be called.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">file</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;&lt;&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s1">&#39;source code not available&#39;</span><span class="p">)</span>

    <span class="n">module</span> <span class="o">=</span> <span class="n">getmodule</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">module</span><span class="p">:</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">linecache</span><span class="o">.</span><span class="n">getlines</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">module</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">linecache</span><span class="o">.</span><span class="n">getlines</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">lines</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s1">&#39;could not get source code&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ismodule</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">lines</span><span class="p">,</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">isclass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">pat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^(\s*)class\s*&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39;\b&#39;</span><span class="p">)</span>
        <span class="c1"># make some effort to find the best matching class definition:</span>
        <span class="c1"># use the one with the least indentation, which is the one</span>
        <span class="c1"># that&#39;s most probably not inside a function definition.</span>
        <span class="n">candidates</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)):</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                <span class="c1"># if it&#39;s at toplevel, it&#39;s already the best one</span>
                <span class="k">if</span> <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">lines</span><span class="p">,</span> <span class="n">i</span>
                <span class="c1"># else add whitespace to candidate list</span>
                <span class="n">candidates</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">i</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">candidates</span><span class="p">:</span>
            <span class="c1"># this will sort by whitespace, and by line number,</span>
            <span class="c1"># less whitespace first</span>
            <span class="n">candidates</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">lines</span><span class="p">,</span> <span class="n">candidates</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s1">&#39;could not find class definition&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ismethod</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="nb">object</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="vm">__func__</span>
    <span class="k">if</span> <span class="n">isfunction</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="nb">object</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="vm">__code__</span>
    <span class="k">if</span> <span class="n">istraceback</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="nb">object</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">tb_frame</span>
    <span class="k">if</span> <span class="n">isframe</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="nb">object</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">f_code</span>
    <span class="k">if</span> <span class="n">iscode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="s1">&#39;co_firstlineno&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s1">&#39;could not find function definition&#39;</span><span class="p">)</span>
        <span class="n">lnum</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">co_firstlineno</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">pat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^(\s*def\s)|(\s*async\s+def\s)|(.*(?&lt;!\w)lambda(:|\s))|^(\s*@)&#39;</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">lnum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="n">lnum</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s1">&#39;lineno is out of bounds&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pat</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="n">lnum</span> <span class="o">=</span> <span class="n">lnum</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">lines</span><span class="p">,</span> <span class="n">lnum</span>
    <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s1">&#39;could not find code object&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">getcomments</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get lines of comments immediately preceding an object&#39;s source code.</span>

<span class="sd">    Returns None when source can&#39;t be found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">lines</span><span class="p">,</span> <span class="n">lnum</span> <span class="o">=</span> <span class="n">findsource</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">ismodule</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="c1"># Look for a comment block at the top of the file.</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">lines</span> <span class="ow">and</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;#!&#39;</span><span class="p">:</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="ow">and</span> <span class="n">lines</span><span class="p">[</span><span class="n">start</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;#&#39;</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="ow">and</span> <span class="n">lines</span><span class="p">[</span><span class="n">start</span><span class="p">][:</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;#&#39;</span><span class="p">:</span>
            <span class="n">comments</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">start</span>
            <span class="k">while</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="ow">and</span> <span class="n">lines</span><span class="p">[</span><span class="n">end</span><span class="p">][:</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;#&#39;</span><span class="p">:</span>
                <span class="n">comments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="n">end</span><span class="p">]</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">())</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">comments</span><span class="p">)</span>

    <span class="c1"># Look for a preceding block of comments at the same indentation.</span>
    <span class="k">elif</span> <span class="n">lnum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">indent</span> <span class="o">=</span> <span class="n">indentsize</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="n">lnum</span><span class="p">])</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">lnum</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">end</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">lines</span><span class="p">[</span><span class="n">end</span><span class="p">]</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;#&#39;</span> <span class="ow">and</span> \
            <span class="n">indentsize</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="n">end</span><span class="p">])</span> <span class="o">==</span> <span class="n">indent</span><span class="p">:</span>
            <span class="n">comments</span> <span class="o">=</span> <span class="p">[</span><span class="n">lines</span><span class="p">[</span><span class="n">end</span><span class="p">]</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">()</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()]</span>
            <span class="k">if</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">comment</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="n">end</span><span class="p">]</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">()</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>
                <span class="k">while</span> <span class="n">comment</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;#&#39;</span> <span class="ow">and</span> <span class="n">indentsize</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="n">end</span><span class="p">])</span> <span class="o">==</span> <span class="n">indent</span><span class="p">:</span>
                    <span class="n">comments</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">comment</span><span class="p">]</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">break</span>
                    <span class="n">comment</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="n">end</span><span class="p">]</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">()</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>
            <span class="k">while</span> <span class="n">comments</span> <span class="ow">and</span> <span class="n">comments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;#&#39;</span><span class="p">:</span>
                <span class="n">comments</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="n">comments</span> <span class="ow">and</span> <span class="n">comments</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;#&#39;</span><span class="p">:</span>
                <span class="n">comments</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">comments</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">EndOfBlock</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span> <span class="k">pass</span>

<span class="k">class</span> <span class="nc">BlockFinder</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Provide a tokeneater() method to detect the end of a code block.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indent</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">islambda</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">started</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">passline</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indecorator</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decoratorhasargs</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">body_col0</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">tokeneater</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="n">srowcol</span><span class="p">,</span> <span class="n">erowcol</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">started</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">indecorator</span><span class="p">:</span>
            <span class="c1"># skip any decorators</span>
            <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;@&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">indecorator</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># look for the first &quot;def&quot;, &quot;class&quot; or &quot;lambda&quot;</span>
            <span class="k">elif</span> <span class="n">token</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;def&quot;</span><span class="p">,</span> <span class="s2">&quot;class&quot;</span><span class="p">,</span> <span class="s2">&quot;lambda&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;lambda&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">islambda</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">started</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">passline</span> <span class="o">=</span> <span class="kc">True</span>    <span class="c1"># skip to the end of the line</span>
        <span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;(&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indecorator</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">decoratorhasargs</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;)&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indecorator</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">indecorator</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">decoratorhasargs</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">tokenize</span><span class="o">.</span><span class="n">NEWLINE</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">passline</span> <span class="o">=</span> <span class="kc">False</span>   <span class="c1"># stop skipping when a NEWLINE is seen</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last</span> <span class="o">=</span> <span class="n">srowcol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">islambda</span><span class="p">:</span>       <span class="c1"># lambdas always end at the first NEWLINE</span>
                <span class="k">raise</span> <span class="n">EndOfBlock</span>
            <span class="c1"># hitting a NEWLINE when in a decorator without args</span>
            <span class="c1"># ends the decorator</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indecorator</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">decoratorhasargs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">indecorator</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">passline</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">tokenize</span><span class="o">.</span><span class="n">INDENT</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">body_col0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">started</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">body_col0</span> <span class="o">=</span> <span class="n">erowcol</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">passline</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">tokenize</span><span class="o">.</span><span class="n">DEDENT</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indent</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="c1"># the end of matching indent/dedent pairs end a block</span>
            <span class="c1"># (note that this only works for &quot;def&quot;/&quot;class&quot; blocks,</span>
            <span class="c1">#  not e.g. for &quot;if: else:&quot; or &quot;try: finally:&quot; blocks)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indent</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">EndOfBlock</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">tokenize</span><span class="o">.</span><span class="n">COMMENT</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">body_col0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">srowcol</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">body_col0</span><span class="p">:</span>
                <span class="c1"># Include comments if indented at least as much as the block</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">last</span> <span class="o">=</span> <span class="n">srowcol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">indent</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">tokenize</span><span class="o">.</span><span class="n">COMMENT</span><span class="p">,</span> <span class="n">tokenize</span><span class="o">.</span><span class="n">NL</span><span class="p">):</span>
            <span class="c1"># any other token on the same indentation level end the previous</span>
            <span class="c1"># block as well, except the pseudo-tokens COMMENT and NL.</span>
            <span class="k">raise</span> <span class="n">EndOfBlock</span>

<span class="k">def</span> <span class="nf">getblock</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extract the block of code at the top of the given list of lines.&quot;&quot;&quot;</span>
    <span class="n">blockfinder</span> <span class="o">=</span> <span class="n">BlockFinder</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="n">tokenize</span><span class="o">.</span><span class="n">generate_tokens</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">.</span><span class="fm">__next__</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_token</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span>
            <span class="n">blockfinder</span><span class="o">.</span><span class="n">tokeneater</span><span class="p">(</span><span class="o">*</span><span class="n">_token</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="n">EndOfBlock</span><span class="p">,</span> <span class="ne">IndentationError</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">return</span> <span class="n">lines</span><span class="p">[:</span><span class="n">blockfinder</span><span class="o">.</span><span class="n">last</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">getsourcelines</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a list of source lines and starting line number for an object.</span>

<span class="sd">    The argument may be a module, class, method, function, traceback, frame,</span>
<span class="sd">    or code object.  The source code is returned as a list of the lines</span>
<span class="sd">    corresponding to the object and the line number indicates where in the</span>
<span class="sd">    original source file the first line of code was found.  An OSError is</span>
<span class="sd">    raised if the source code cannot be retrieved.&quot;&quot;&quot;</span>
    <span class="nb">object</span> <span class="o">=</span> <span class="n">unwrap</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
    <span class="n">lines</span><span class="p">,</span> <span class="n">lnum</span> <span class="o">=</span> <span class="n">findsource</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">istraceback</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="nb">object</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">tb_frame</span>

    <span class="c1"># for module or frame that corresponds to module, return all source lines</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ismodule</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span> <span class="ow">or</span>
        <span class="p">(</span><span class="n">isframe</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">object</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span> <span class="o">==</span> <span class="s2">&quot;&lt;module&gt;&quot;</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">lines</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">getblock</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="n">lnum</span><span class="p">:]),</span> <span class="n">lnum</span> <span class="o">+</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">getsource</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the text of the source code for an object.</span>

<span class="sd">    The argument may be a module, class, method, function, traceback, frame,</span>
<span class="sd">    or code object.  The source code is returned as a single string.  An</span>
<span class="sd">    OSError is raised if the source code cannot be retrieved.&quot;&quot;&quot;</span>
    <span class="n">lines</span><span class="p">,</span> <span class="n">lnum</span> <span class="o">=</span> <span class="n">getsourcelines</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

<span class="c1"># --------------------------------------------------- class tree extraction</span>
<span class="k">def</span> <span class="nf">walktree</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Recursive helper function for getclasstree().&quot;&quot;&quot;</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">classes</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;__module__&#39;</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">classes</span><span class="p">:</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">walktree</span><span class="p">(</span><span class="n">children</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">children</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">results</span>

<span class="k">def</span> <span class="nf">getclasstree</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Arrange the given list of classes into a hierarchy of nested lists.</span>

<span class="sd">    Where a nested list appears, it contains classes derived from the class</span>
<span class="sd">    whose entry immediately precedes the list.  Each entry is a 2-tuple</span>
<span class="sd">    containing a class and a tuple of its base classes.  If the &#39;unique&#39;</span>
<span class="sd">    argument is true, exactly one entry appears in the returned structure</span>
<span class="sd">    for each class in the given list.  Otherwise, classes using multiple</span>
<span class="sd">    inheritance and their descendants will appear multiple times.&quot;&quot;&quot;</span>
    <span class="n">children</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">roots</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">classes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">parent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                    <span class="n">children</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">children</span><span class="p">[</span><span class="n">parent</span><span class="p">]:</span>
                    <span class="n">children</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">unique</span> <span class="ow">and</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">classes</span><span class="p">:</span> <span class="k">break</span>
        <span class="k">elif</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">:</span>
            <span class="n">roots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">classes</span><span class="p">:</span>
            <span class="n">roots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">walktree</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

<span class="c1"># ------------------------------------------------ argument list extraction</span>
<span class="n">Arguments</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Arguments&#39;</span><span class="p">,</span> <span class="s1">&#39;args, varargs, varkw&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">getargs</span><span class="p">(</span><span class="n">co</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get information about the arguments accepted by a code object.</span>

<span class="sd">    Three things are returned: (args, varargs, varkw), where</span>
<span class="sd">    &#39;args&#39; is the list of argument names. Keyword-only arguments are</span>
<span class="sd">    appended. &#39;varargs&#39; and &#39;varkw&#39; are the names of the * and **</span>
<span class="sd">    arguments or None.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">iscode</span><span class="p">(</span><span class="n">co</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{!r}</span><span class="s1"> is not a code object&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">co</span><span class="p">))</span>

    <span class="n">names</span> <span class="o">=</span> <span class="n">co</span><span class="o">.</span><span class="n">co_varnames</span>
    <span class="n">nargs</span> <span class="o">=</span> <span class="n">co</span><span class="o">.</span><span class="n">co_argcount</span>
    <span class="n">nkwargs</span> <span class="o">=</span> <span class="n">co</span><span class="o">.</span><span class="n">co_kwonlyargcount</span>
    <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">names</span><span class="p">[:</span><span class="n">nargs</span><span class="p">])</span>
    <span class="n">kwonlyargs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">nargs</span><span class="p">:</span><span class="n">nargs</span><span class="o">+</span><span class="n">nkwargs</span><span class="p">])</span>
    <span class="n">step</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">nargs</span> <span class="o">+=</span> <span class="n">nkwargs</span>
    <span class="n">varargs</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">co</span><span class="o">.</span><span class="n">co_flags</span> <span class="o">&amp;</span> <span class="n">CO_VARARGS</span><span class="p">:</span>
        <span class="n">varargs</span> <span class="o">=</span> <span class="n">co</span><span class="o">.</span><span class="n">co_varnames</span><span class="p">[</span><span class="n">nargs</span><span class="p">]</span>
        <span class="n">nargs</span> <span class="o">=</span> <span class="n">nargs</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">varkw</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">co</span><span class="o">.</span><span class="n">co_flags</span> <span class="o">&amp;</span> <span class="n">CO_VARKEYWORDS</span><span class="p">:</span>
        <span class="n">varkw</span> <span class="o">=</span> <span class="n">co</span><span class="o">.</span><span class="n">co_varnames</span><span class="p">[</span><span class="n">nargs</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">Arguments</span><span class="p">(</span><span class="n">args</span> <span class="o">+</span> <span class="n">kwonlyargs</span><span class="p">,</span> <span class="n">varargs</span><span class="p">,</span> <span class="n">varkw</span><span class="p">)</span>

<span class="n">ArgSpec</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;ArgSpec&#39;</span><span class="p">,</span> <span class="s1">&#39;args varargs keywords defaults&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">getargspec</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the names and default values of a function&#39;s parameters.</span>

<span class="sd">    A tuple of four things is returned: (args, varargs, keywords, defaults).</span>
<span class="sd">    &#39;args&#39; is a list of the argument names, including keyword-only argument names.</span>
<span class="sd">    &#39;varargs&#39; and &#39;keywords&#39; are the names of the * and ** parameters or None.</span>
<span class="sd">    &#39;defaults&#39; is an n-tuple of the default values of the last n parameters.</span>

<span class="sd">    This function is deprecated, as it does not support annotations or</span>
<span class="sd">    keyword-only parameters and will raise ValueError if either is present</span>
<span class="sd">    on the supplied callable.</span>

<span class="sd">    For a more structured introspection API, use inspect.signature() instead.</span>

<span class="sd">    Alternatively, use getfullargspec() for an API with a similar namedtuple</span>
<span class="sd">    based interface, but full support for annotations and keyword-only</span>
<span class="sd">    parameters.</span>

<span class="sd">    Deprecated since Python 3.5, use `inspect.getfullargspec()`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;inspect.getargspec() is deprecated since Python 3.0, &quot;</span>
                  <span class="s2">&quot;use inspect.signature() or inspect.getfullargspec()&quot;</span><span class="p">,</span>
                  <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">args</span><span class="p">,</span> <span class="n">varargs</span><span class="p">,</span> <span class="n">varkw</span><span class="p">,</span> <span class="n">defaults</span><span class="p">,</span> <span class="n">kwonlyargs</span><span class="p">,</span> <span class="n">kwonlydefaults</span><span class="p">,</span> <span class="n">ann</span> <span class="o">=</span> \
        <span class="n">getfullargspec</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kwonlyargs</span> <span class="ow">or</span> <span class="n">ann</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Function has keyword-only parameters or annotations&quot;</span>
                         <span class="s2">&quot;, use inspect.signature() API which can support them&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ArgSpec</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">varargs</span><span class="p">,</span> <span class="n">varkw</span><span class="p">,</span> <span class="n">defaults</span><span class="p">)</span>

<span class="n">FullArgSpec</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;FullArgSpec&#39;</span><span class="p">,</span>
    <span class="s1">&#39;args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">getfullargspec</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the names and default values of a callable object&#39;s parameters.</span>

<span class="sd">    A tuple of seven things is returned:</span>
<span class="sd">    (args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations).</span>
<span class="sd">    &#39;args&#39; is a list of the parameter names.</span>
<span class="sd">    &#39;varargs&#39; and &#39;varkw&#39; are the names of the * and ** parameters or None.</span>
<span class="sd">    &#39;defaults&#39; is an n-tuple of the default values of the last n parameters.</span>
<span class="sd">    &#39;kwonlyargs&#39; is a list of keyword-only parameter names.</span>
<span class="sd">    &#39;kwonlydefaults&#39; is a dictionary mapping names from kwonlyargs to defaults.</span>
<span class="sd">    &#39;annotations&#39; is a dictionary mapping parameter names to annotations.</span>

<span class="sd">    Notable differences from inspect.signature():</span>
<span class="sd">      - the &quot;self&quot; parameter is always reported, even for bound methods</span>
<span class="sd">      - wrapper chains defined by __wrapped__ *not* unwrapped automatically</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Re: `skip_bound_arg=False`</span>
        <span class="c1">#</span>
        <span class="c1"># There is a notable difference in behaviour between getfullargspec</span>
        <span class="c1"># and Signature: the former always returns &#39;self&#39; parameter for bound</span>
        <span class="c1"># methods, whereas the Signature always shows the actual calling</span>
        <span class="c1"># signature of the passed object.</span>
        <span class="c1">#</span>
        <span class="c1"># To simulate this behaviour, we &quot;unbind&quot; bound methods, to trick</span>
        <span class="c1"># inspect.signature to always return their first parameter (&quot;self&quot;,</span>
        <span class="c1"># usually)</span>

        <span class="c1"># Re: `follow_wrapper_chains=False`</span>
        <span class="c1">#</span>
        <span class="c1"># getfullargspec() historically ignored __wrapped__ attributes,</span>
        <span class="c1"># so we ensure that remains the case in 3.3+</span>

        <span class="n">sig</span> <span class="o">=</span> <span class="n">_signature_from_callable</span><span class="p">(</span><span class="n">func</span><span class="p">,</span>
                                       <span class="n">follow_wrapper_chains</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                       <span class="n">skip_bound_arg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                       <span class="n">sigcls</span><span class="o">=</span><span class="n">Signature</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
        <span class="c1"># Most of the times &#39;signature&#39; will raise ValueError.</span>
        <span class="c1"># But, it can also raise AttributeError, and, maybe something</span>
        <span class="c1"># else. So to be fully backwards compatible, we catch all</span>
        <span class="c1"># possible exceptions here, and reraise a TypeError.</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;unsupported callable&#39;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">ex</span>

    <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">varargs</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">varkw</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">posonlyargs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">kwonlyargs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">defaults</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">annotations</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">defaults</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">kwdefaults</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">sig</span><span class="o">.</span><span class="n">return_annotation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">sig</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="n">annotations</span><span class="p">[</span><span class="s1">&#39;return&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">return_annotation</span>

    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="n">kind</span> <span class="ow">is</span> <span class="n">_POSITIONAL_ONLY</span><span class="p">:</span>
            <span class="n">posonlyargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">param</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="n">defaults</span> <span class="o">+=</span> <span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">default</span><span class="p">,)</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="ow">is</span> <span class="n">_POSITIONAL_OR_KEYWORD</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">param</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="n">defaults</span> <span class="o">+=</span> <span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">default</span><span class="p">,)</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="ow">is</span> <span class="n">_VAR_POSITIONAL</span><span class="p">:</span>
            <span class="n">varargs</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="ow">is</span> <span class="n">_KEYWORD_ONLY</span><span class="p">:</span>
            <span class="n">kwonlyargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">param</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="n">kwdefaults</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="ow">is</span> <span class="n">_VAR_KEYWORD</span><span class="p">:</span>
            <span class="n">varkw</span> <span class="o">=</span> <span class="n">name</span>

        <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">annotation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">param</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="n">annotations</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">annotation</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">kwdefaults</span><span class="p">:</span>
        <span class="c1"># compatibility with &#39;func.__kwdefaults__&#39;</span>
        <span class="n">kwdefaults</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">defaults</span><span class="p">:</span>
        <span class="c1"># compatibility with &#39;func.__defaults__&#39;</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">FullArgSpec</span><span class="p">(</span><span class="n">posonlyargs</span> <span class="o">+</span> <span class="n">args</span><span class="p">,</span> <span class="n">varargs</span><span class="p">,</span> <span class="n">varkw</span><span class="p">,</span> <span class="n">defaults</span><span class="p">,</span>
                       <span class="n">kwonlyargs</span><span class="p">,</span> <span class="n">kwdefaults</span><span class="p">,</span> <span class="n">annotations</span><span class="p">)</span>


<span class="n">ArgInfo</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;ArgInfo&#39;</span><span class="p">,</span> <span class="s1">&#39;args varargs keywords locals&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">getargvalues</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get information about arguments passed into a particular frame.</span>

<span class="sd">    A tuple of four things is returned: (args, varargs, varkw, locals).</span>
<span class="sd">    &#39;args&#39; is a list of the argument names.</span>
<span class="sd">    &#39;varargs&#39; and &#39;varkw&#39; are the names of the * and ** arguments or None.</span>
<span class="sd">    &#39;locals&#39; is the locals dictionary of the given frame.&quot;&quot;&quot;</span>
    <span class="n">args</span><span class="p">,</span> <span class="n">varargs</span><span class="p">,</span> <span class="n">varkw</span> <span class="o">=</span> <span class="n">getargs</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">f_code</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ArgInfo</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">varargs</span><span class="p">,</span> <span class="n">varkw</span><span class="p">,</span> <span class="n">frame</span><span class="o">.</span><span class="n">f_locals</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">formatannotation</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="n">base_module</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="s1">&#39;__module__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;typing&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;typing.&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">annotation</span><span class="o">.</span><span class="vm">__module__</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;builtins&#39;</span><span class="p">,</span> <span class="n">base_module</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">annotation</span><span class="o">.</span><span class="vm">__qualname__</span>
        <span class="k">return</span> <span class="n">annotation</span><span class="o">.</span><span class="vm">__module__</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="n">annotation</span><span class="o">.</span><span class="vm">__qualname__</span>
    <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">formatannotationrelativeto</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">module</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="s1">&#39;__module__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_formatannotation</span><span class="p">(</span><span class="n">annotation</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">formatannotation</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="n">module</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_formatannotation</span>

<span class="k">def</span> <span class="nf">formatargspec</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">varargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">varkw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">defaults</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">kwonlyargs</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwonlydefaults</span><span class="o">=</span><span class="p">{},</span> <span class="n">annotations</span><span class="o">=</span><span class="p">{},</span>
                  <span class="n">formatarg</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
                  <span class="n">formatvarargs</span><span class="o">=</span><span class="k">lambda</span> <span class="n">name</span><span class="p">:</span> <span class="s1">&#39;*&#39;</span> <span class="o">+</span> <span class="n">name</span><span class="p">,</span>
                  <span class="n">formatvarkw</span><span class="o">=</span><span class="k">lambda</span> <span class="n">name</span><span class="p">:</span> <span class="s1">&#39;**&#39;</span> <span class="o">+</span> <span class="n">name</span><span class="p">,</span>
                  <span class="n">formatvalue</span><span class="o">=</span><span class="k">lambda</span> <span class="n">value</span><span class="p">:</span> <span class="s1">&#39;=&#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">value</span><span class="p">),</span>
                  <span class="n">formatreturns</span><span class="o">=</span><span class="k">lambda</span> <span class="n">text</span><span class="p">:</span> <span class="s1">&#39; -&gt; &#39;</span> <span class="o">+</span> <span class="n">text</span><span class="p">,</span>
                  <span class="n">formatannotation</span><span class="o">=</span><span class="n">formatannotation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Format an argument spec from the values returned by getfullargspec.</span>

<span class="sd">    The first seven arguments are (args, varargs, varkw, defaults,</span>
<span class="sd">    kwonlyargs, kwonlydefaults, annotations).  The other five arguments</span>
<span class="sd">    are the corresponding optional formatting functions that are called to</span>
<span class="sd">    turn names and values into strings.  The last argument is an optional</span>
<span class="sd">    function to format the sequence of arguments.</span>

<span class="sd">    Deprecated since Python 3.5: use the `signature` function and `Signature`</span>
<span class="sd">    objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>

    <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;`formatargspec` is deprecated since Python 3.5. Use `signature` and &quot;</span>
         <span class="s2">&quot;the `Signature` object directly&quot;</span><span class="p">,</span>
         <span class="ne">DeprecationWarning</span><span class="p">,</span>
         <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">formatargandannotation</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">formatarg</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">annotations</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="n">formatannotation</span><span class="p">(</span><span class="n">annotations</span><span class="p">[</span><span class="n">arg</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="n">specs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">defaults</span><span class="p">:</span>
        <span class="n">firstdefault</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">defaults</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">formatargandannotation</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">defaults</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">firstdefault</span><span class="p">:</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span> <span class="o">+</span> <span class="n">formatvalue</span><span class="p">(</span><span class="n">defaults</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">firstdefault</span><span class="p">])</span>
        <span class="n">specs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">varargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">specs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">formatvarargs</span><span class="p">(</span><span class="n">formatargandannotation</span><span class="p">(</span><span class="n">varargs</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">kwonlyargs</span><span class="p">:</span>
            <span class="n">specs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kwonlyargs</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">kwonlyarg</span> <span class="ow">in</span> <span class="n">kwonlyargs</span><span class="p">:</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="n">formatargandannotation</span><span class="p">(</span><span class="n">kwonlyarg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">kwonlydefaults</span> <span class="ow">and</span> <span class="n">kwonlyarg</span> <span class="ow">in</span> <span class="n">kwonlydefaults</span><span class="p">:</span>
                <span class="n">spec</span> <span class="o">+=</span> <span class="n">formatvalue</span><span class="p">(</span><span class="n">kwonlydefaults</span><span class="p">[</span><span class="n">kwonlyarg</span><span class="p">])</span>
            <span class="n">specs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">varkw</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">specs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">formatvarkw</span><span class="p">(</span><span class="n">formatargandannotation</span><span class="p">(</span><span class="n">varkw</span><span class="p">)))</span>
    <span class="n">result</span> <span class="o">=</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span>
    <span class="k">if</span> <span class="s1">&#39;return&#39;</span> <span class="ow">in</span> <span class="n">annotations</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">formatreturns</span><span class="p">(</span><span class="n">formatannotation</span><span class="p">(</span><span class="n">annotations</span><span class="p">[</span><span class="s1">&#39;return&#39;</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">formatargvalues</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">varargs</span><span class="p">,</span> <span class="n">varkw</span><span class="p">,</span> <span class="nb">locals</span><span class="p">,</span>
                    <span class="n">formatarg</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
                    <span class="n">formatvarargs</span><span class="o">=</span><span class="k">lambda</span> <span class="n">name</span><span class="p">:</span> <span class="s1">&#39;*&#39;</span> <span class="o">+</span> <span class="n">name</span><span class="p">,</span>
                    <span class="n">formatvarkw</span><span class="o">=</span><span class="k">lambda</span> <span class="n">name</span><span class="p">:</span> <span class="s1">&#39;**&#39;</span> <span class="o">+</span> <span class="n">name</span><span class="p">,</span>
                    <span class="n">formatvalue</span><span class="o">=</span><span class="k">lambda</span> <span class="n">value</span><span class="p">:</span> <span class="s1">&#39;=&#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">value</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;Format an argument spec from the 4 values returned by getargvalues.</span>

<span class="sd">    The first four arguments are (args, varargs, varkw, locals).  The</span>
<span class="sd">    next four arguments are the corresponding optional formatting functions</span>
<span class="sd">    that are called to turn names and values into strings.  The ninth</span>
<span class="sd">    argument is an optional function to format the sequence of arguments.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">locals</span><span class="o">=</span><span class="nb">locals</span><span class="p">,</span>
                <span class="n">formatarg</span><span class="o">=</span><span class="n">formatarg</span><span class="p">,</span> <span class="n">formatvalue</span><span class="o">=</span><span class="n">formatvalue</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">formatarg</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="n">formatvalue</span><span class="p">(</span><span class="nb">locals</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
    <span class="n">specs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)):</span>
        <span class="n">specs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">convert</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">varargs</span><span class="p">:</span>
        <span class="n">specs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">formatvarargs</span><span class="p">(</span><span class="n">varargs</span><span class="p">)</span> <span class="o">+</span> <span class="n">formatvalue</span><span class="p">(</span><span class="nb">locals</span><span class="p">[</span><span class="n">varargs</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">varkw</span><span class="p">:</span>
        <span class="n">specs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">formatvarkw</span><span class="p">(</span><span class="n">varkw</span><span class="p">)</span> <span class="o">+</span> <span class="n">formatvalue</span><span class="p">(</span><span class="nb">locals</span><span class="p">[</span><span class="n">varkw</span><span class="p">]))</span>
    <span class="k">return</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span>

<span class="k">def</span> <span class="nf">_missing_arguments</span><span class="p">(</span><span class="n">f_name</span><span class="p">,</span> <span class="n">argnames</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="nb">repr</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">argnames</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
    <span class="n">missing</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">missing</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">missing</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">names</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="s2">&quot;, </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">names</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span>
        <span class="k">del</span> <span class="n">names</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">+</span> <span class="n">tail</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">() missing </span><span class="si">%i</span><span class="s2"> required </span><span class="si">%s</span><span class="s2"> argument</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="n">f_name</span><span class="p">,</span> <span class="n">missing</span><span class="p">,</span>
                      <span class="s2">&quot;positional&quot;</span> <span class="k">if</span> <span class="n">pos</span> <span class="k">else</span> <span class="s2">&quot;keyword-only&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">missing</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_too_many</span><span class="p">(</span><span class="n">f_name</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwonly</span><span class="p">,</span> <span class="n">varargs</span><span class="p">,</span> <span class="n">defcount</span><span class="p">,</span> <span class="n">given</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="n">atleast</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-</span> <span class="n">defcount</span>
    <span class="n">kwonly_given</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">arg</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">kwonly</span> <span class="k">if</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">values</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">varargs</span><span class="p">:</span>
        <span class="n">plural</span> <span class="o">=</span> <span class="n">atleast</span> <span class="o">!=</span> <span class="mi">1</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="s2">&quot;at least </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">atleast</span><span class="p">,)</span>
    <span class="k">elif</span> <span class="n">defcount</span><span class="p">:</span>
        <span class="n">plural</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="s2">&quot;from </span><span class="si">%d</span><span class="s2"> to </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">atleast</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plural</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
    <span class="n">kwonly_sig</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">if</span> <span class="n">kwonly_given</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot; positional argument</span><span class="si">%s</span><span class="s2"> (and </span><span class="si">%d</span><span class="s2"> keyword-only argument</span><span class="si">%s</span><span class="s2">)&quot;</span>
        <span class="n">kwonly_sig</span> <span class="o">=</span> <span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;s&quot;</span> <span class="k">if</span> <span class="n">given</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">kwonly_given</span><span class="p">,</span>
                             <span class="s2">&quot;s&quot;</span> <span class="k">if</span> <span class="n">kwonly_given</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">() takes </span><span class="si">%s</span><span class="s2"> positional argument</span><span class="si">%s</span><span class="s2"> but </span><span class="si">%d%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> given&quot;</span> <span class="o">%</span>
            <span class="p">(</span><span class="n">f_name</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span> <span class="k">if</span> <span class="n">plural</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">given</span><span class="p">,</span> <span class="n">kwonly_sig</span><span class="p">,</span>
             <span class="s2">&quot;was&quot;</span> <span class="k">if</span> <span class="n">given</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">kwonly_given</span> <span class="k">else</span> <span class="s2">&quot;were&quot;</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">getcallargs</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="n">positional</span><span class="p">,</span> <span class="o">**</span><span class="n">named</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the mapping of arguments to values.</span>

<span class="sd">    A dict is returned, with keys the function argument names (including the</span>
<span class="sd">    names of the * and ** arguments, if any), and values the respective bound</span>
<span class="sd">    values from &#39;positional&#39; and &#39;named&#39;.&quot;&quot;&quot;</span>
    <span class="n">spec</span> <span class="o">=</span> <span class="n">getfullargspec</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">args</span><span class="p">,</span> <span class="n">varargs</span><span class="p">,</span> <span class="n">varkw</span><span class="p">,</span> <span class="n">defaults</span><span class="p">,</span> <span class="n">kwonlyargs</span><span class="p">,</span> <span class="n">kwonlydefaults</span><span class="p">,</span> <span class="n">ann</span> <span class="o">=</span> <span class="n">spec</span>
    <span class="n">f_name</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="n">arg2value</span> <span class="o">=</span> <span class="p">{}</span>


    <span class="k">if</span> <span class="n">ismethod</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="ow">and</span> <span class="n">func</span><span class="o">.</span><span class="vm">__self__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># implicit &#39;self&#39; (or &#39;cls&#39; for classmethods) argument</span>
        <span class="n">positional</span> <span class="o">=</span> <span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__self__</span><span class="p">,)</span> <span class="o">+</span> <span class="n">positional</span>
    <span class="n">num_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positional</span><span class="p">)</span>
    <span class="n">num_args</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">num_defaults</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">defaults</span><span class="p">)</span> <span class="k">if</span> <span class="n">defaults</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">num_pos</span><span class="p">,</span> <span class="n">num_args</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">arg2value</span><span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">positional</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">varargs</span><span class="p">:</span>
        <span class="n">arg2value</span><span class="p">[</span><span class="n">varargs</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">positional</span><span class="p">[</span><span class="n">n</span><span class="p">:])</span>
    <span class="n">possible_kwargs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">args</span> <span class="o">+</span> <span class="n">kwonlyargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">varkw</span><span class="p">:</span>
        <span class="n">arg2value</span><span class="p">[</span><span class="n">varkw</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">kw</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">named</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">kw</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">possible_kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">varkw</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">() got an unexpected keyword argument </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span>
                                <span class="p">(</span><span class="n">f_name</span><span class="p">,</span> <span class="n">kw</span><span class="p">))</span>
            <span class="n">arg2value</span><span class="p">[</span><span class="n">varkw</span><span class="p">][</span><span class="n">kw</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">arg2value</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">() got multiple values for argument </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span>
                            <span class="p">(</span><span class="n">f_name</span><span class="p">,</span> <span class="n">kw</span><span class="p">))</span>
        <span class="n">arg2value</span><span class="p">[</span><span class="n">kw</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">if</span> <span class="n">num_pos</span> <span class="o">&gt;</span> <span class="n">num_args</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">varargs</span><span class="p">:</span>
        <span class="n">_too_many</span><span class="p">(</span><span class="n">f_name</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwonlyargs</span><span class="p">,</span> <span class="n">varargs</span><span class="p">,</span> <span class="n">num_defaults</span><span class="p">,</span>
                   <span class="n">num_pos</span><span class="p">,</span> <span class="n">arg2value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num_pos</span> <span class="o">&lt;</span> <span class="n">num_args</span><span class="p">:</span>
        <span class="n">req</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="n">num_args</span> <span class="o">-</span> <span class="n">num_defaults</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">req</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">arg2value</span><span class="p">:</span>
                <span class="n">_missing_arguments</span><span class="p">(</span><span class="n">f_name</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">arg2value</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">num_args</span> <span class="o">-</span> <span class="n">num_defaults</span><span class="p">:]):</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">arg2value</span><span class="p">:</span>
                <span class="n">arg2value</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaults</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">missing</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">kwarg</span> <span class="ow">in</span> <span class="n">kwonlyargs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">kwarg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">arg2value</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwonlydefaults</span> <span class="ow">and</span> <span class="n">kwarg</span> <span class="ow">in</span> <span class="n">kwonlydefaults</span><span class="p">:</span>
                <span class="n">arg2value</span><span class="p">[</span><span class="n">kwarg</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwonlydefaults</span><span class="p">[</span><span class="n">kwarg</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">missing</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
        <span class="n">_missing_arguments</span><span class="p">(</span><span class="n">f_name</span><span class="p">,</span> <span class="n">kwonlyargs</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">arg2value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">arg2value</span>

<span class="n">ClosureVars</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;ClosureVars&#39;</span><span class="p">,</span> <span class="s1">&#39;nonlocals globals builtins unbound&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">getclosurevars</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the mapping of free variables to their current values.</span>

<span class="sd">    Returns a named tuple of dicts mapping the current nonlocal, global</span>
<span class="sd">    and builtin references as seen by the body of the function. A final</span>
<span class="sd">    set of unbound names that could not be resolved is also provided.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">ismethod</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__func__</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">isfunction</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{!r}</span><span class="s2"> is not a Python function&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">func</span><span class="p">))</span>

    <span class="n">code</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__code__</span>
    <span class="c1"># Nonlocal references are named in co_freevars and resolved</span>
    <span class="c1"># by looking them up in __closure__ by positional index</span>
    <span class="k">if</span> <span class="n">func</span><span class="o">.</span><span class="vm">__closure__</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nonlocal_vars</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nonlocal_vars</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">var</span> <span class="p">:</span> <span class="n">cell</span><span class="o">.</span><span class="n">cell_contents</span>
            <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">cell</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">code</span><span class="o">.</span><span class="n">co_freevars</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__closure__</span><span class="p">)</span>
       <span class="p">}</span>

    <span class="c1"># Global and builtin references are named in co_names and resolved</span>
    <span class="c1"># by looking them up in __globals__ or __builtins__</span>
    <span class="n">global_ns</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__globals__</span>
    <span class="n">builtin_ns</span> <span class="o">=</span> <span class="n">global_ns</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;__builtins__&quot;</span><span class="p">,</span> <span class="n">builtins</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ismodule</span><span class="p">(</span><span class="n">builtin_ns</span><span class="p">):</span>
        <span class="n">builtin_ns</span> <span class="o">=</span> <span class="n">builtin_ns</span><span class="o">.</span><span class="vm">__dict__</span>
    <span class="n">global_vars</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">builtin_vars</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">unbound_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">code</span><span class="o">.</span><span class="n">co_names</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="s2">&quot;True&quot;</span><span class="p">,</span> <span class="s2">&quot;False&quot;</span><span class="p">):</span>
            <span class="c1"># Because these used to be builtins instead of keywords, they</span>
            <span class="c1"># may still show up as name references. We ignore them.</span>
            <span class="k">continue</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">global_vars</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">global_ns</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">builtin_vars</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">builtin_ns</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">unbound_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ClosureVars</span><span class="p">(</span><span class="n">nonlocal_vars</span><span class="p">,</span> <span class="n">global_vars</span><span class="p">,</span>
                       <span class="n">builtin_vars</span><span class="p">,</span> <span class="n">unbound_names</span><span class="p">)</span>

<span class="c1"># -------------------------------------------------- stack frame extraction</span>

<span class="n">Traceback</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Traceback&#39;</span><span class="p">,</span> <span class="s1">&#39;filename lineno function code_context index&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">getframeinfo</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get information about a frame or traceback object.</span>

<span class="sd">    A tuple of five things is returned: the filename, the line number of</span>
<span class="sd">    the current line, the function name, a list of lines of context from</span>
<span class="sd">    the source code, and the index of the current line within that list.</span>
<span class="sd">    The optional second argument specifies the number of lines of context</span>
<span class="sd">    to return, which are centered around the current line.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">istraceback</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
        <span class="n">lineno</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">tb_lineno</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">tb_frame</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lineno</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">f_lineno</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isframe</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{!r}</span><span class="s1"> is not a frame or traceback object&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">frame</span><span class="p">))</span>

    <span class="n">filename</span> <span class="o">=</span> <span class="n">getsourcefile</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span> <span class="ow">or</span> <span class="n">getfile</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">context</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">lineno</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">context</span><span class="o">//</span><span class="mi">2</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">lines</span><span class="p">,</span> <span class="n">lnum</span> <span class="o">=</span> <span class="n">findsource</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">-</span> <span class="n">context</span><span class="p">))</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span><span class="o">+</span><span class="n">context</span><span class="p">]</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">lineno</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">start</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">index</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">Traceback</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">lineno</span><span class="p">,</span> <span class="n">frame</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">getlineno</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the line number from a frame object, allowing for optimization.&quot;&quot;&quot;</span>
    <span class="c1"># FrameType.f_lineno is now a descriptor that grovels co_lnotab</span>
    <span class="k">return</span> <span class="n">frame</span><span class="o">.</span><span class="n">f_lineno</span>

<span class="n">FrameInfo</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;FrameInfo&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;frame&#39;</span><span class="p">,)</span> <span class="o">+</span> <span class="n">Traceback</span><span class="o">.</span><span class="n">_fields</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">getouterframes</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get a list of records for a frame and all higher (calling) frames.</span>

<span class="sd">    Each record contains a frame object, filename, line number, function</span>
<span class="sd">    name, a list of lines of context, and index within the context.&quot;&quot;&quot;</span>
    <span class="n">framelist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">frame</span><span class="p">:</span>
        <span class="n">frameinfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">frame</span><span class="p">,)</span> <span class="o">+</span> <span class="n">getframeinfo</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
        <span class="n">framelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FrameInfo</span><span class="p">(</span><span class="o">*</span><span class="n">frameinfo</span><span class="p">))</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">f_back</span>
    <span class="k">return</span> <span class="n">framelist</span>

<span class="k">def</span> <span class="nf">getinnerframes</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get a list of records for a traceback&#39;s frame and all lower frames.</span>

<span class="sd">    Each record contains a frame object, filename, line number, function</span>
<span class="sd">    name, a list of lines of context, and index within the context.&quot;&quot;&quot;</span>
    <span class="n">framelist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">tb</span><span class="p">:</span>
        <span class="n">frameinfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">tb</span><span class="o">.</span><span class="n">tb_frame</span><span class="p">,)</span> <span class="o">+</span> <span class="n">getframeinfo</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
        <span class="n">framelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FrameInfo</span><span class="p">(</span><span class="o">*</span><span class="n">frameinfo</span><span class="p">))</span>
        <span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="o">.</span><span class="n">tb_next</span>
    <span class="k">return</span> <span class="n">framelist</span>

<span class="k">def</span> <span class="nf">currentframe</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Return the frame of the caller or None if this is not possible.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="s2">&quot;_getframe&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>

<span class="k">def</span> <span class="nf">stack</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a list of records for the stack above the caller&#39;s frame.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">getouterframes</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">context</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a list of records for the stack below the current exception.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">getinnerframes</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">2</span><span class="p">],</span> <span class="n">context</span><span class="p">)</span>


<span class="c1"># ------------------------------------------------ static version of getattr</span>

<span class="n">_sentinel</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">_static_getmro</span><span class="p">(</span><span class="n">klass</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;__mro__&#39;</span><span class="p">]</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="n">klass</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_check_instance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
    <span class="n">instance_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">instance_dict</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;__dict__&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">instance_dict</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">_sentinel</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_class</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">_static_getmro</span><span class="p">(</span><span class="n">klass</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">_shadowed_dict</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span> <span class="ow">is</span> <span class="n">_sentinel</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">entry</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
    <span class="k">return</span> <span class="n">_sentinel</span>

<span class="k">def</span> <span class="nf">_is_type</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">_static_getmro</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>

<span class="k">def</span> <span class="nf">_shadowed_dict</span><span class="p">(</span><span class="n">klass</span><span class="p">):</span>
    <span class="n">dict_attr</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;__dict__&quot;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">_static_getmro</span><span class="p">(</span><span class="n">klass</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">class_dict</span> <span class="o">=</span> <span class="n">dict_attr</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="n">entry</span><span class="p">)[</span><span class="s2">&quot;__dict__&quot;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">class_dict</span><span class="p">)</span> <span class="ow">is</span> <span class="n">types</span><span class="o">.</span><span class="n">GetSetDescriptorType</span> <span class="ow">and</span>
                    <span class="n">class_dict</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__dict__&quot;</span> <span class="ow">and</span>
                    <span class="n">class_dict</span><span class="o">.</span><span class="vm">__objclass__</span> <span class="ow">is</span> <span class="n">entry</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">class_dict</span>
    <span class="k">return</span> <span class="n">_sentinel</span>

<span class="k">def</span> <span class="nf">getattr_static</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">_sentinel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Retrieve attributes without triggering dynamic lookup via the</span>
<span class="sd">       descriptor protocol,  __getattr__ or __getattribute__.</span>

<span class="sd">       Note: this function may not be able to retrieve all attributes</span>
<span class="sd">       that getattr can fetch (like dynamically created attributes)</span>
<span class="sd">       and may find attributes that getattr can&#39;t (like descriptors</span>
<span class="sd">       that raise AttributeError). It can also return descriptor objects</span>
<span class="sd">       instead of instance members in some cases. See the</span>
<span class="sd">       documentation for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">instance_result</span> <span class="o">=</span> <span class="n">_sentinel</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_type</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="n">klass</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="n">dict_attr</span> <span class="o">=</span> <span class="n">_shadowed_dict</span><span class="p">(</span><span class="n">klass</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dict_attr</span> <span class="ow">is</span> <span class="n">_sentinel</span> <span class="ow">or</span>
            <span class="nb">type</span><span class="p">(</span><span class="n">dict_attr</span><span class="p">)</span> <span class="ow">is</span> <span class="n">types</span><span class="o">.</span><span class="n">MemberDescriptorType</span><span class="p">):</span>
            <span class="n">instance_result</span> <span class="o">=</span> <span class="n">_check_instance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">klass</span> <span class="o">=</span> <span class="n">obj</span>

    <span class="n">klass_result</span> <span class="o">=</span> <span class="n">_check_class</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">instance_result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_sentinel</span> <span class="ow">and</span> <span class="n">klass_result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_sentinel</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_check_class</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">klass_result</span><span class="p">),</span> <span class="s1">&#39;__get__&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_sentinel</span> <span class="ow">and</span>
            <span class="n">_check_class</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">klass_result</span><span class="p">),</span> <span class="s1">&#39;__set__&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_sentinel</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">klass_result</span>

    <span class="k">if</span> <span class="n">instance_result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_sentinel</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">instance_result</span>
    <span class="k">if</span> <span class="n">klass_result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_sentinel</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">klass_result</span>

    <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="n">klass</span><span class="p">:</span>
        <span class="c1"># for types we check the metaclass too</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">_static_getmro</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">klass</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">_shadowed_dict</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span> <span class="ow">is</span> <span class="n">_sentinel</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">entry</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span>
    <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_sentinel</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default</span>
    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>


<span class="c1"># ------------------------------------------------ generator introspection</span>

<span class="n">GEN_CREATED</span> <span class="o">=</span> <span class="s1">&#39;GEN_CREATED&#39;</span>
<span class="n">GEN_RUNNING</span> <span class="o">=</span> <span class="s1">&#39;GEN_RUNNING&#39;</span>
<span class="n">GEN_SUSPENDED</span> <span class="o">=</span> <span class="s1">&#39;GEN_SUSPENDED&#39;</span>
<span class="n">GEN_CLOSED</span> <span class="o">=</span> <span class="s1">&#39;GEN_CLOSED&#39;</span>

<span class="k">def</span> <span class="nf">getgeneratorstate</span><span class="p">(</span><span class="n">generator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get current state of a generator-iterator.</span>

<span class="sd">    Possible states are:</span>
<span class="sd">      GEN_CREATED: Waiting to start execution.</span>
<span class="sd">      GEN_RUNNING: Currently being executed by the interpreter.</span>
<span class="sd">      GEN_SUSPENDED: Currently suspended at a yield expression.</span>
<span class="sd">      GEN_CLOSED: Execution has completed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">generator</span><span class="o">.</span><span class="n">gi_running</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">GEN_RUNNING</span>
    <span class="k">if</span> <span class="n">generator</span><span class="o">.</span><span class="n">gi_frame</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">GEN_CLOSED</span>
    <span class="k">if</span> <span class="n">generator</span><span class="o">.</span><span class="n">gi_frame</span><span class="o">.</span><span class="n">f_lasti</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">GEN_CREATED</span>
    <span class="k">return</span> <span class="n">GEN_SUSPENDED</span>


<span class="k">def</span> <span class="nf">getgeneratorlocals</span><span class="p">(</span><span class="n">generator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the mapping of generator local variables to their current values.</span>

<span class="sd">    A dict is returned, with the keys the local variable names and values the</span>
<span class="sd">    bound values.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">isgenerator</span><span class="p">(</span><span class="n">generator</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{!r}</span><span class="s2"> is not a Python generator&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">generator</span><span class="p">))</span>

    <span class="n">frame</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span> <span class="s2">&quot;gi_frame&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">frame</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">generator</span><span class="o">.</span><span class="n">gi_frame</span><span class="o">.</span><span class="n">f_locals</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{}</span>


<span class="c1"># ------------------------------------------------ coroutine introspection</span>

<span class="n">CORO_CREATED</span> <span class="o">=</span> <span class="s1">&#39;CORO_CREATED&#39;</span>
<span class="n">CORO_RUNNING</span> <span class="o">=</span> <span class="s1">&#39;CORO_RUNNING&#39;</span>
<span class="n">CORO_SUSPENDED</span> <span class="o">=</span> <span class="s1">&#39;CORO_SUSPENDED&#39;</span>
<span class="n">CORO_CLOSED</span> <span class="o">=</span> <span class="s1">&#39;CORO_CLOSED&#39;</span>

<span class="k">def</span> <span class="nf">getcoroutinestate</span><span class="p">(</span><span class="n">coroutine</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get current state of a coroutine object.</span>

<span class="sd">    Possible states are:</span>
<span class="sd">      CORO_CREATED: Waiting to start execution.</span>
<span class="sd">      CORO_RUNNING: Currently being executed by the interpreter.</span>
<span class="sd">      CORO_SUSPENDED: Currently suspended at an await expression.</span>
<span class="sd">      CORO_CLOSED: Execution has completed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">coroutine</span><span class="o">.</span><span class="n">cr_running</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CORO_RUNNING</span>
    <span class="k">if</span> <span class="n">coroutine</span><span class="o">.</span><span class="n">cr_frame</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CORO_CLOSED</span>
    <span class="k">if</span> <span class="n">coroutine</span><span class="o">.</span><span class="n">cr_frame</span><span class="o">.</span><span class="n">f_lasti</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CORO_CREATED</span>
    <span class="k">return</span> <span class="n">CORO_SUSPENDED</span>


<span class="k">def</span> <span class="nf">getcoroutinelocals</span><span class="p">(</span><span class="n">coroutine</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the mapping of coroutine local variables to their current values.</span>

<span class="sd">    A dict is returned, with the keys the local variable names and values the</span>
<span class="sd">    bound values.&quot;&quot;&quot;</span>
    <span class="n">frame</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">coroutine</span><span class="p">,</span> <span class="s2">&quot;cr_frame&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">frame</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">frame</span><span class="o">.</span><span class="n">f_locals</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{}</span>


<span class="c1">###############################################################################</span>
<span class="c1">### Function Signature Object (PEP 362)</span>
<span class="c1">###############################################################################</span>


<span class="n">_WrapperDescriptor</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="nb">type</span><span class="o">.</span><span class="fm">__call__</span><span class="p">)</span>
<span class="n">_MethodWrapper</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="nb">all</span><span class="o">.</span><span class="fm">__call__</span><span class="p">)</span>
<span class="n">_ClassMethodWrapper</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="nb">int</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;from_bytes&#39;</span><span class="p">])</span>

<span class="n">_NonUserDefinedCallables</span> <span class="o">=</span> <span class="p">(</span><span class="n">_WrapperDescriptor</span><span class="p">,</span>
                            <span class="n">_MethodWrapper</span><span class="p">,</span>
                            <span class="n">_ClassMethodWrapper</span><span class="p">,</span>
                            <span class="n">types</span><span class="o">.</span><span class="n">BuiltinFunctionType</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_signature_get_user_defined_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">method_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Private helper. Checks if ``cls`` has an attribute</span>
<span class="sd">    named ``method_name`` and returns it only if it is a</span>
<span class="sd">    pure python function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">meth</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">method_name</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">meth</span><span class="p">,</span> <span class="n">_NonUserDefinedCallables</span><span class="p">):</span>
            <span class="c1"># Once &#39;__signature__&#39; will be added to &#39;C&#39;-level</span>
            <span class="c1"># callables, this check won&#39;t be necessary</span>
            <span class="k">return</span> <span class="n">meth</span>


<span class="k">def</span> <span class="nf">_signature_get_partial</span><span class="p">(</span><span class="n">wrapped_sig</span><span class="p">,</span> <span class="n">partial</span><span class="p">,</span> <span class="n">extra_args</span><span class="o">=</span><span class="p">()):</span>
    <span class="sd">&quot;&quot;&quot;Private helper to calculate how &#39;wrapped_sig&#39; signature will</span>
<span class="sd">    look like after applying a &#39;functools.partial&#39; object (or alike)</span>
<span class="sd">    on it.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">old_params</span> <span class="o">=</span> <span class="n">wrapped_sig</span><span class="o">.</span><span class="n">parameters</span>
    <span class="n">new_params</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="n">old_params</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

    <span class="n">partial_args</span> <span class="o">=</span> <span class="n">partial</span><span class="o">.</span><span class="n">args</span> <span class="ow">or</span> <span class="p">()</span>
    <span class="n">partial_keywords</span> <span class="o">=</span> <span class="n">partial</span><span class="o">.</span><span class="n">keywords</span> <span class="ow">or</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">extra_args</span><span class="p">:</span>
        <span class="n">partial_args</span> <span class="o">=</span> <span class="n">extra_args</span> <span class="o">+</span> <span class="n">partial_args</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">ba</span> <span class="o">=</span> <span class="n">wrapped_sig</span><span class="o">.</span><span class="n">bind_partial</span><span class="p">(</span><span class="o">*</span><span class="n">partial_args</span><span class="p">,</span> <span class="o">**</span><span class="n">partial_keywords</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;partial object </span><span class="si">{!r}</span><span class="s1"> has incorrect arguments&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">partial</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">ex</span>


    <span class="n">transform_to_kwonly</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">old_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">arg_value</span> <span class="o">=</span> <span class="n">ba</span><span class="o">.</span><span class="n">arguments</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="ow">is</span> <span class="n">_POSITIONAL_ONLY</span><span class="p">:</span>
                <span class="c1"># If positional-only parameter is bound by partial,</span>
                <span class="c1"># it effectively disappears from the signature</span>
                <span class="n">new_params</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">param_name</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="ow">is</span> <span class="n">_POSITIONAL_OR_KEYWORD</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">partial_keywords</span><span class="p">:</span>
                    <span class="c1"># This means that this parameter, and all parameters</span>
                    <span class="c1"># after it should be keyword-only (and var-positional</span>
                    <span class="c1"># should be removed). Here&#39;s why. Consider the following</span>
                    <span class="c1"># function:</span>
                    <span class="c1">#     foo(a, b, *args, c):</span>
                    <span class="c1">#         pass</span>
                    <span class="c1">#</span>
                    <span class="c1"># &quot;partial(foo, a=&#39;spam&#39;)&quot; will have the following</span>
                    <span class="c1"># signature: &quot;(*, a=&#39;spam&#39;, b, c)&quot;. Because attempting</span>
                    <span class="c1"># to call that partial with &quot;(10, 20)&quot; arguments will</span>
                    <span class="c1"># raise a TypeError, saying that &quot;a&quot; argument received</span>
                    <span class="c1"># multiple values.</span>
                    <span class="n">transform_to_kwonly</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="c1"># Set the new default value</span>
                    <span class="n">new_params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">arg_value</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># was passed as a positional argument</span>
                    <span class="n">new_params</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="k">continue</span>

            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="ow">is</span> <span class="n">_KEYWORD_ONLY</span><span class="p">:</span>
                <span class="c1"># Set the new default value</span>
                <span class="n">new_params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">arg_value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">transform_to_kwonly</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_POSITIONAL_ONLY</span>

            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="ow">is</span> <span class="n">_POSITIONAL_OR_KEYWORD</span><span class="p">:</span>
                <span class="n">new_param</span> <span class="o">=</span> <span class="n">new_params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">_KEYWORD_ONLY</span><span class="p">)</span>
                <span class="n">new_params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_param</span>
                <span class="n">new_params</span><span class="o">.</span><span class="n">move_to_end</span><span class="p">(</span><span class="n">param_name</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_KEYWORD_ONLY</span><span class="p">,</span> <span class="n">_VAR_KEYWORD</span><span class="p">):</span>
                <span class="n">new_params</span><span class="o">.</span><span class="n">move_to_end</span><span class="p">(</span><span class="n">param_name</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="ow">is</span> <span class="n">_VAR_POSITIONAL</span><span class="p">:</span>
                <span class="n">new_params</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapped_sig</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="n">new_params</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">_signature_bound_method</span><span class="p">(</span><span class="n">sig</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Private helper to transform signatures for unbound</span>
<span class="sd">    functions to bound methods.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">params</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span> <span class="ow">or</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_VAR_KEYWORD</span><span class="p">,</span> <span class="n">_KEYWORD_ONLY</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid method signature&#39;</span><span class="p">)</span>

    <span class="n">kind</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">kind</span>
    <span class="k">if</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_POSITIONAL_OR_KEYWORD</span><span class="p">,</span> <span class="n">_POSITIONAL_ONLY</span><span class="p">):</span>
        <span class="c1"># Drop first parameter:</span>
        <span class="c1"># &#39;(p1, p2[, ...])&#39; -&gt; &#39;(p2[, ...])&#39;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_VAR_POSITIONAL</span><span class="p">:</span>
            <span class="c1"># Unless we add a new parameter type we never</span>
            <span class="c1"># get here</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid argument type&#39;</span><span class="p">)</span>
        <span class="c1"># It&#39;s a var-positional parameter.</span>
        <span class="c1"># Do nothing. &#39;(*args[, ...])&#39; -&gt; &#39;(*args[, ...])&#39;</span>

    <span class="k">return</span> <span class="n">sig</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_signature_is_builtin</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Private helper to test if `obj` is a callable that might</span>
<span class="sd">    support Argument Clinic&#39;s __text_signature__ protocol.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">isbuiltin</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">or</span>
            <span class="n">ismethoddescriptor</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">or</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">_NonUserDefinedCallables</span><span class="p">)</span> <span class="ow">or</span>
            <span class="c1"># Can&#39;t test &#39;isinstance(type)&#39; here, as it would</span>
            <span class="c1"># also be True for regular python classes</span>
            <span class="n">obj</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="nb">object</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_signature_is_functionlike</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Private helper to test if `obj` is a duck type of FunctionType.</span>
<span class="sd">    A good example of such objects are functions compiled with</span>
<span class="sd">    Cython, which have all attributes that a pure Python function</span>
<span class="sd">    would have, but have their code statically compiled.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">or</span> <span class="n">isclass</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="c1"># All function-like objects are obviously callables,</span>
        <span class="c1"># and not classes.</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="n">name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">code</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__code__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">defaults</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__defaults__&#39;</span><span class="p">,</span> <span class="n">_void</span><span class="p">)</span> <span class="c1"># Important to use _void ...</span>
    <span class="n">kwdefaults</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__kwdefaults__&#39;</span><span class="p">,</span> <span class="n">_void</span><span class="p">)</span> <span class="c1"># ... and not None here</span>
    <span class="n">annotations</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__annotations__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">CodeType</span><span class="p">)</span> <span class="ow">and</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span>
            <span class="p">(</span><span class="n">defaults</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">defaults</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span>
            <span class="p">(</span><span class="n">kwdefaults</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kwdefaults</span><span class="p">,</span> <span class="nb">dict</span><span class="p">))</span> <span class="ow">and</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">annotations</span><span class="p">,</span> <span class="nb">dict</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_signature_get_bound_param</span><span class="p">(</span><span class="n">spec</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Private helper to get first parameter name from a</span>
<span class="sd">    __text_signature__ of a builtin method, which should</span>
<span class="sd">    be in the following format: &#39;($param1, ...)&#39;.</span>
<span class="sd">    Assumptions are that the first argument won&#39;t have</span>
<span class="sd">    a default value or an annotation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="n">spec</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;($&#39;</span><span class="p">)</span>

    <span class="n">pos</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">)</span>

    <span class="n">cpos</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">cpos</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">cpos</span> <span class="o">&gt;</span> <span class="n">pos</span>

    <span class="n">cpos</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">cpos</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">cpos</span> <span class="o">&gt;</span> <span class="n">pos</span>

    <span class="k">return</span> <span class="n">spec</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">pos</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_signature_strip_non_python_syntax</span><span class="p">(</span><span class="n">signature</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Private helper function. Takes a signature in Argument Clinic&#39;s</span>
<span class="sd">    extended signature format.</span>

<span class="sd">    Returns a tuple of three things:</span>
<span class="sd">      * that signature re-rendered in standard Python syntax,</span>
<span class="sd">      * the index of the &quot;self&quot; parameter (generally 0), or None if</span>
<span class="sd">        the function does not have a &quot;self&quot; parameter, and</span>
<span class="sd">      * the index of the last &quot;positional only&quot; parameter,</span>
<span class="sd">        or None if the signature has no positional-only parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">signature</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">signature</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="n">self_parameter</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">last_positional_only</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">signature</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)]</span>
    <span class="n">generator</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">.</span><span class="fm">__next__</span>
    <span class="n">token_stream</span> <span class="o">=</span> <span class="n">tokenize</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">generator</span><span class="p">)</span>

    <span class="n">delayed_comma</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">skip_next_comma</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">text</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">add</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">append</span>

    <span class="n">current_parameter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">OP</span> <span class="o">=</span> <span class="n">token</span><span class="o">.</span><span class="n">OP</span>
    <span class="n">ERRORTOKEN</span> <span class="o">=</span> <span class="n">token</span><span class="o">.</span><span class="n">ERRORTOKEN</span>

    <span class="c1"># token stream always starts with ENCODING token, skip it</span>
    <span class="n">t</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">token_stream</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">t</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">tokenize</span><span class="o">.</span><span class="n">ENCODING</span>

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">token_stream</span><span class="p">:</span>
        <span class="nb">type</span><span class="p">,</span> <span class="n">string</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">string</span>

        <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">OP</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;,&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">skip_next_comma</span><span class="p">:</span>
                    <span class="n">skip_next_comma</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="ow">not</span> <span class="n">delayed_comma</span>
                    <span class="n">delayed_comma</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">current_parameter</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;/&#39;</span><span class="p">:</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="n">skip_next_comma</span>
                <span class="k">assert</span> <span class="n">last_positional_only</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="n">skip_next_comma</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">last_positional_only</span> <span class="o">=</span> <span class="n">current_parameter</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">continue</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">type</span> <span class="o">==</span> <span class="n">ERRORTOKEN</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;$&#39;</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">self_parameter</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="n">self_parameter</span> <span class="o">=</span> <span class="n">current_parameter</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">delayed_comma</span><span class="p">:</span>
            <span class="n">delayed_comma</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="nb">type</span> <span class="o">==</span> <span class="n">OP</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;)&#39;</span><span class="p">)):</span>
                <span class="n">add</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">)</span>
        <span class="n">add</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;,&#39;</span><span class="p">):</span>
            <span class="n">add</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
    <span class="n">clean_signature</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">clean_signature</span><span class="p">,</span> <span class="n">self_parameter</span><span class="p">,</span> <span class="n">last_positional_only</span>


<span class="k">def</span> <span class="nf">_signature_fromstr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">skip_bound_arg</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Private helper to parse content of &#39;__text_signature__&#39;</span>
<span class="sd">    and return a Signature based on it.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Lazy import ast because it&#39;s relatively heavy and</span>
    <span class="c1"># it&#39;s not used for other than this function.</span>
    <span class="kn">import</span> <span class="nn">ast</span>

    <span class="n">Parameter</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_parameter_cls</span>

    <span class="n">clean_signature</span><span class="p">,</span> <span class="n">self_parameter</span><span class="p">,</span> <span class="n">last_positional_only</span> <span class="o">=</span> \
        <span class="n">_signature_strip_non_python_syntax</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="n">program</span> <span class="o">=</span> <span class="s2">&quot;def foo&quot;</span> <span class="o">+</span> <span class="n">clean_signature</span> <span class="o">+</span> <span class="s2">&quot;: pass&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">module</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">program</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">SyntaxError</span><span class="p">:</span>
        <span class="n">module</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{!r}</span><span class="s2"> builtin has invalid signature&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">parameters</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">empty</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span>
    <span class="n">invalid</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

    <span class="n">module</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">module_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">module_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__module__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">module_name</span><span class="p">:</span>
        <span class="n">module</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">module_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">module</span><span class="p">:</span>
            <span class="n">module_dict</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="vm">__dict__</span>
    <span class="n">sys_module_dict</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">parse_name</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">annotation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Annotations are not currently supported&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">arg</span>

    <span class="k">def</span> <span class="nf">wrap_value</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">module_dict</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sys_module_dict</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))):</span>
            <span class="k">return</span> <span class="n">ast</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

    <span class="k">class</span> <span class="nc">RewriteSymbolics</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">NodeTransformer</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">visit_Attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">node</span>
            <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Attribute</span><span class="p">):</span>
                <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">attr</span><span class="p">)</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>
            <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">wrap_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">visit_Name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Load</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">wrap_value</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">p</span><span class="p">(</span><span class="n">name_node</span><span class="p">,</span> <span class="n">default_node</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">empty</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">parse_name</span><span class="p">(</span><span class="n">name_node</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="n">invalid</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">default_node</span> <span class="ow">and</span> <span class="n">default_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_empty</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">default_node</span> <span class="o">=</span> <span class="n">RewriteSymbolics</span><span class="p">()</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">default_node</span><span class="p">)</span>
                <span class="n">o</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">default_node</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">o</span> <span class="o">=</span> <span class="n">invalid</span>
            <span class="k">if</span> <span class="n">o</span> <span class="ow">is</span> <span class="n">invalid</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">default</span> <span class="o">=</span> <span class="n">o</span> <span class="k">if</span> <span class="n">o</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">invalid</span> <span class="k">else</span> <span class="n">default</span>
        <span class="n">parameters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Parameter</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">empty</span><span class="p">))</span>

    <span class="c1"># non-keyword-only parameters</span>
    <span class="n">args</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
    <span class="n">defaults</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">defaults</span><span class="p">)</span>
    <span class="nb">iter</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">zip_longest</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">defaults</span><span class="p">,</span> <span class="n">fillvalue</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">last_positional_only</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_ONLY</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">iter</span><span class="p">))):</span>
        <span class="n">p</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">last_positional_only</span><span class="p">:</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span>

    <span class="c1"># *args</span>
    <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">vararg</span><span class="p">:</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span>
        <span class="n">p</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">vararg</span><span class="p">,</span> <span class="n">empty</span><span class="p">)</span>

    <span class="c1"># keyword-only arguments</span>
    <span class="n">kind</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">default</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">kwonlyargs</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">kw_defaults</span><span class="p">):</span>
        <span class="n">p</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>

    <span class="c1"># **kwargs</span>
    <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">kwarg</span><span class="p">:</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span>
        <span class="n">p</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">kwarg</span><span class="p">,</span> <span class="n">empty</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">self_parameter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Possibly strip the bound argument:</span>
        <span class="c1">#    - We *always* strip first bound argument if</span>
        <span class="c1">#      it is a module.</span>
        <span class="c1">#    - We don&#39;t strip first bound argument if</span>
        <span class="c1">#      skip_bound_arg is False.</span>
        <span class="k">assert</span> <span class="n">parameters</span>
        <span class="n">_self</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__self__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">self_isbound</span> <span class="o">=</span> <span class="n">_self</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">self_ismodule</span> <span class="o">=</span> <span class="n">ismodule</span><span class="p">(</span><span class="n">_self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">self_isbound</span> <span class="ow">and</span> <span class="p">(</span><span class="n">self_ismodule</span> <span class="ow">or</span> <span class="n">skip_bound_arg</span><span class="p">):</span>
            <span class="n">parameters</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># for builtins, self parameter is always positional-only!</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_ONLY</span><span class="p">)</span>
            <span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>

    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">empty</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_signature_from_builtin</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">skip_bound_arg</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Private helper function to get signature for</span>
<span class="sd">    builtin callables.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">_signature_is_builtin</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{!r}</span><span class="s2"> is not a Python builtin &quot;</span>
                        <span class="s2">&quot;function&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">func</span><span class="p">))</span>

    <span class="n">s</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s2">&quot;__text_signature__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no signature found for builtin </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">func</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">_signature_fromstr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">skip_bound_arg</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_signature_from_function</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">skip_bound_arg</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Private helper: constructs Signature for the given python function.&quot;&quot;&quot;</span>

    <span class="n">is_duck_function</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isfunction</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">_signature_is_functionlike</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="n">is_duck_function</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If it&#39;s not a pure Python function, and not a duck type</span>
            <span class="c1"># of pure function:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{!r}</span><span class="s1"> is not a Python function&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">func</span><span class="p">))</span>

    <span class="n">s</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s2">&quot;__text_signature__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">s</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_signature_fromstr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">skip_bound_arg</span><span class="p">)</span>

    <span class="n">Parameter</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_parameter_cls</span>

    <span class="c1"># Parameter information.</span>
    <span class="n">func_code</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__code__</span>
    <span class="n">pos_count</span> <span class="o">=</span> <span class="n">func_code</span><span class="o">.</span><span class="n">co_argcount</span>
    <span class="n">arg_names</span> <span class="o">=</span> <span class="n">func_code</span><span class="o">.</span><span class="n">co_varnames</span>
    <span class="n">posonly_count</span> <span class="o">=</span> <span class="n">func_code</span><span class="o">.</span><span class="n">co_posonlyargcount</span>
    <span class="n">positional</span> <span class="o">=</span> <span class="n">arg_names</span><span class="p">[:</span><span class="n">pos_count</span><span class="p">]</span>
    <span class="n">keyword_only_count</span> <span class="o">=</span> <span class="n">func_code</span><span class="o">.</span><span class="n">co_kwonlyargcount</span>
    <span class="n">keyword_only</span> <span class="o">=</span> <span class="n">arg_names</span><span class="p">[</span><span class="n">pos_count</span><span class="p">:</span><span class="n">pos_count</span> <span class="o">+</span> <span class="n">keyword_only_count</span><span class="p">]</span>
    <span class="n">annotations</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__annotations__</span>
    <span class="n">defaults</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__defaults__</span>
    <span class="n">kwdefaults</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__kwdefaults__</span>

    <span class="k">if</span> <span class="n">defaults</span><span class="p">:</span>
        <span class="n">pos_default_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">defaults</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pos_default_count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">parameters</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">non_default_count</span> <span class="o">=</span> <span class="n">pos_count</span> <span class="o">-</span> <span class="n">pos_default_count</span>
    <span class="n">posonly_left</span> <span class="o">=</span> <span class="n">posonly_count</span>

    <span class="c1"># Non-keyword-only parameters w/o defaults.</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">positional</span><span class="p">[:</span><span class="n">non_default_count</span><span class="p">]:</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="n">_POSITIONAL_ONLY</span> <span class="k">if</span> <span class="n">posonly_left</span> <span class="k">else</span> <span class="n">_POSITIONAL_OR_KEYWORD</span>
        <span class="n">annotation</span> <span class="o">=</span> <span class="n">annotations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">_empty</span><span class="p">)</span>
        <span class="n">parameters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Parameter</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">annotation</span><span class="p">,</span>
                                    <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">posonly_left</span><span class="p">:</span>
            <span class="n">posonly_left</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="c1"># ... w/ defaults.</span>
    <span class="k">for</span> <span class="n">offset</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">positional</span><span class="p">[</span><span class="n">non_default_count</span><span class="p">:]):</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="n">_POSITIONAL_ONLY</span> <span class="k">if</span> <span class="n">posonly_left</span> <span class="k">else</span> <span class="n">_POSITIONAL_OR_KEYWORD</span>
        <span class="n">annotation</span> <span class="o">=</span> <span class="n">annotations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">_empty</span><span class="p">)</span>
        <span class="n">parameters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Parameter</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">annotation</span><span class="p">,</span>
                                    <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                                    <span class="n">default</span><span class="o">=</span><span class="n">defaults</span><span class="p">[</span><span class="n">offset</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">posonly_left</span><span class="p">:</span>
            <span class="n">posonly_left</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="c1"># *args</span>
    <span class="k">if</span> <span class="n">func_code</span><span class="o">.</span><span class="n">co_flags</span> <span class="o">&amp;</span> <span class="n">CO_VARARGS</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">arg_names</span><span class="p">[</span><span class="n">pos_count</span> <span class="o">+</span> <span class="n">keyword_only_count</span><span class="p">]</span>
        <span class="n">annotation</span> <span class="o">=</span> <span class="n">annotations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">_empty</span><span class="p">)</span>
        <span class="n">parameters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Parameter</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">annotation</span><span class="p">,</span>
                                    <span class="n">kind</span><span class="o">=</span><span class="n">_VAR_POSITIONAL</span><span class="p">))</span>

    <span class="c1"># Keyword-only parameters.</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">keyword_only</span><span class="p">:</span>
        <span class="n">default</span> <span class="o">=</span> <span class="n">_empty</span>
        <span class="k">if</span> <span class="n">kwdefaults</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">default</span> <span class="o">=</span> <span class="n">kwdefaults</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">_empty</span><span class="p">)</span>

        <span class="n">annotation</span> <span class="o">=</span> <span class="n">annotations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">_empty</span><span class="p">)</span>
        <span class="n">parameters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Parameter</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">annotation</span><span class="p">,</span>
                                    <span class="n">kind</span><span class="o">=</span><span class="n">_KEYWORD_ONLY</span><span class="p">,</span>
                                    <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">))</span>
    <span class="c1"># **kwargs</span>
    <span class="k">if</span> <span class="n">func_code</span><span class="o">.</span><span class="n">co_flags</span> <span class="o">&amp;</span> <span class="n">CO_VARKEYWORDS</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">pos_count</span> <span class="o">+</span> <span class="n">keyword_only_count</span>
        <span class="k">if</span> <span class="n">func_code</span><span class="o">.</span><span class="n">co_flags</span> <span class="o">&amp;</span> <span class="n">CO_VARARGS</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">name</span> <span class="o">=</span> <span class="n">arg_names</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="n">annotation</span> <span class="o">=</span> <span class="n">annotations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">_empty</span><span class="p">)</span>
        <span class="n">parameters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Parameter</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">annotation</span><span class="p">,</span>
                                    <span class="n">kind</span><span class="o">=</span><span class="n">_VAR_KEYWORD</span><span class="p">))</span>

    <span class="c1"># Is &#39;func&#39; is a pure Python function - don&#39;t validate the</span>
    <span class="c1"># parameters list (for correct order and defaults), it should be OK.</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span>
               <span class="n">return_annotation</span><span class="o">=</span><span class="n">annotations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;return&#39;</span><span class="p">,</span> <span class="n">_empty</span><span class="p">),</span>
               <span class="n">__validate_parameters__</span><span class="o">=</span><span class="n">is_duck_function</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_signature_from_callable</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                             <span class="n">follow_wrapper_chains</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">skip_bound_arg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">sigcls</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Private helper function to get signature for arbitrary</span>
<span class="sd">    callable objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{!r}</span><span class="s1"> is not a callable object&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">):</span>
        <span class="c1"># In this case we skip the first parameter of the underlying</span>
        <span class="c1"># function (usually `self` or `cls`).</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">_signature_from_callable</span><span class="p">(</span>
            <span class="n">obj</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span>
            <span class="n">follow_wrapper_chains</span><span class="o">=</span><span class="n">follow_wrapper_chains</span><span class="p">,</span>
            <span class="n">skip_bound_arg</span><span class="o">=</span><span class="n">skip_bound_arg</span><span class="p">,</span>
            <span class="n">sigcls</span><span class="o">=</span><span class="n">sigcls</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">skip_bound_arg</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_signature_bound_method</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sig</span>

    <span class="c1"># Was this function wrapped by a decorator?</span>
    <span class="k">if</span> <span class="n">follow_wrapper_chains</span><span class="p">:</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">unwrap</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s2">&quot;__signature__&quot;</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">):</span>
            <span class="c1"># If the unwrapped object is a *method*, we might want to</span>
            <span class="c1"># skip its first parameter (self).</span>
            <span class="c1"># See test_signature_wrapped_bound_method for details.</span>
            <span class="k">return</span> <span class="n">_signature_from_callable</span><span class="p">(</span>
                <span class="n">obj</span><span class="p">,</span>
                <span class="n">follow_wrapper_chains</span><span class="o">=</span><span class="n">follow_wrapper_chains</span><span class="p">,</span>
                <span class="n">skip_bound_arg</span><span class="o">=</span><span class="n">skip_bound_arg</span><span class="p">,</span>
                <span class="n">sigcls</span><span class="o">=</span><span class="n">sigcls</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">__signature__</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sig</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">Signature</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s1">&#39;unexpected object </span><span class="si">{!r}</span><span class="s1"> in __signature__ &#39;</span>
                    <span class="s1">&#39;attribute&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sig</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">sig</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">partialmethod</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_partialmethod</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">partialmethod</span><span class="p">,</span> <span class="n">functools</span><span class="o">.</span><span class="n">partialmethod</span><span class="p">):</span>
            <span class="c1"># Unbound partialmethod (see functools.partialmethod)</span>
            <span class="c1"># This means, that we need to calculate the signature</span>
            <span class="c1"># as if it&#39;s a regular partial object, but taking into</span>
            <span class="c1"># account that the first positional argument</span>
            <span class="c1"># (usually `self`, or `cls`) will not be passed</span>
            <span class="c1"># automatically (as for boundmethods)</span>

            <span class="n">wrapped_sig</span> <span class="o">=</span> <span class="n">_signature_from_callable</span><span class="p">(</span>
                <span class="n">partialmethod</span><span class="o">.</span><span class="n">func</span><span class="p">,</span>
                <span class="n">follow_wrapper_chains</span><span class="o">=</span><span class="n">follow_wrapper_chains</span><span class="p">,</span>
                <span class="n">skip_bound_arg</span><span class="o">=</span><span class="n">skip_bound_arg</span><span class="p">,</span>
                <span class="n">sigcls</span><span class="o">=</span><span class="n">sigcls</span><span class="p">)</span>

            <span class="n">sig</span> <span class="o">=</span> <span class="n">_signature_get_partial</span><span class="p">(</span><span class="n">wrapped_sig</span><span class="p">,</span> <span class="n">partialmethod</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,))</span>
            <span class="n">first_wrapped_param</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">wrapped_sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">first_wrapped_param</span><span class="o">.</span><span class="n">kind</span> <span class="ow">is</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">:</span>
                <span class="c1"># First argument of the wrapped callable is `*args`, as in</span>
                <span class="c1"># `partialmethod(lambda *args)`.</span>
                <span class="k">return</span> <span class="n">sig</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sig_params</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                <span class="k">assert</span> <span class="p">(</span><span class="ow">not</span> <span class="n">sig_params</span> <span class="ow">or</span>
                        <span class="n">first_wrapped_param</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">sig_params</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">new_params</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_wrapped_param</span><span class="p">,)</span> <span class="o">+</span> <span class="n">sig_params</span>
                <span class="k">return</span> <span class="n">sig</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="n">new_params</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">isfunction</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_signature_is_functionlike</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="c1"># If it&#39;s a pure Python function, or an object that is duck type</span>
        <span class="c1"># of a Python function (Cython functions, for instance), then:</span>
        <span class="k">return</span> <span class="n">_signature_from_function</span><span class="p">(</span><span class="n">sigcls</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span>
                                        <span class="n">skip_bound_arg</span><span class="o">=</span><span class="n">skip_bound_arg</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">_signature_is_builtin</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_signature_from_builtin</span><span class="p">(</span><span class="n">sigcls</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span>
                                       <span class="n">skip_bound_arg</span><span class="o">=</span><span class="n">skip_bound_arg</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">):</span>
        <span class="n">wrapped_sig</span> <span class="o">=</span> <span class="n">_signature_from_callable</span><span class="p">(</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">func</span><span class="p">,</span>
            <span class="n">follow_wrapper_chains</span><span class="o">=</span><span class="n">follow_wrapper_chains</span><span class="p">,</span>
            <span class="n">skip_bound_arg</span><span class="o">=</span><span class="n">skip_bound_arg</span><span class="p">,</span>
            <span class="n">sigcls</span><span class="o">=</span><span class="n">sigcls</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_signature_get_partial</span><span class="p">(</span><span class="n">wrapped_sig</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

    <span class="n">sig</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
        <span class="c1"># obj is a class or a metaclass</span>

        <span class="c1"># First, let&#39;s see if it has an overloaded __call__ defined</span>
        <span class="c1"># in its metaclass</span>
        <span class="n">call</span> <span class="o">=</span> <span class="n">_signature_get_user_defined_method</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">_signature_from_callable</span><span class="p">(</span>
                <span class="n">call</span><span class="p">,</span>
                <span class="n">follow_wrapper_chains</span><span class="o">=</span><span class="n">follow_wrapper_chains</span><span class="p">,</span>
                <span class="n">skip_bound_arg</span><span class="o">=</span><span class="n">skip_bound_arg</span><span class="p">,</span>
                <span class="n">sigcls</span><span class="o">=</span><span class="n">sigcls</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Now we check if the &#39;obj&#39; class has a &#39;__new__&#39; method</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">_signature_get_user_defined_method</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__new__&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="n">_signature_from_callable</span><span class="p">(</span>
                    <span class="n">new</span><span class="p">,</span>
                    <span class="n">follow_wrapper_chains</span><span class="o">=</span><span class="n">follow_wrapper_chains</span><span class="p">,</span>
                    <span class="n">skip_bound_arg</span><span class="o">=</span><span class="n">skip_bound_arg</span><span class="p">,</span>
                    <span class="n">sigcls</span><span class="o">=</span><span class="n">sigcls</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Finally, we should have at least __init__ implemented</span>
                <span class="n">init</span> <span class="o">=</span> <span class="n">_signature_get_user_defined_method</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__init__&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">sig</span> <span class="o">=</span> <span class="n">_signature_from_callable</span><span class="p">(</span>
                        <span class="n">init</span><span class="p">,</span>
                        <span class="n">follow_wrapper_chains</span><span class="o">=</span><span class="n">follow_wrapper_chains</span><span class="p">,</span>
                        <span class="n">skip_bound_arg</span><span class="o">=</span><span class="n">skip_bound_arg</span><span class="p">,</span>
                        <span class="n">sigcls</span><span class="o">=</span><span class="n">sigcls</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># At this point we know, that `obj` is a class, with no user-</span>
            <span class="c1"># defined &#39;__init__&#39;, &#39;__new__&#39;, or class-level &#39;__call__&#39;</span>

            <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># Since &#39;__text_signature__&#39; is implemented as a</span>
                <span class="c1"># descriptor that extracts text signature from the</span>
                <span class="c1"># class docstring, if &#39;obj&#39; is derived from a builtin</span>
                <span class="c1"># class, its own &#39;__text_signature__&#39; may be &#39;None&#39;.</span>
                <span class="c1"># Therefore, we go through the MRO (except the last</span>
                <span class="c1"># class in there, which is &#39;object&#39;) to find the first</span>
                <span class="c1"># class with non-empty text signature.</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">text_sig</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">__text_signature__</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">text_sig</span><span class="p">:</span>
                        <span class="c1"># If &#39;obj&#39; class has a __text_signature__ attribute:</span>
                        <span class="c1"># return a signature based on it</span>
                        <span class="k">return</span> <span class="n">_signature_fromstr</span><span class="p">(</span><span class="n">sigcls</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">text_sig</span><span class="p">)</span>

            <span class="c1"># No &#39;__text_signature__&#39; was found for the &#39;obj&#39; class.</span>
            <span class="c1"># Last option is to check if its &#39;__init__&#39; is</span>
            <span class="c1"># object.__init__ or type.__init__.</span>
            <span class="k">if</span> <span class="nb">type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">:</span>
                <span class="c1"># We have a class (not metaclass), but no user-defined</span>
                <span class="c1"># __init__ or __new__ for it</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="fm">__init__</span> <span class="ow">is</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__init__</span> <span class="ow">and</span>
                    <span class="n">obj</span><span class="o">.</span><span class="fm">__new__</span> <span class="ow">is</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">):</span>
                    <span class="c1"># Return a signature of &#39;object&#39; builtin.</span>
                    <span class="k">return</span> <span class="n">sigcls</span><span class="o">.</span><span class="n">from_callable</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;no signature found for builtin type </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>

    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">_NonUserDefinedCallables</span><span class="p">):</span>
        <span class="c1"># An object with __call__</span>
        <span class="c1"># We also check that the &#39;obj&#39; is not an instance of</span>
        <span class="c1"># _WrapperDescriptor or _MethodWrapper to avoid</span>
        <span class="c1"># infinite recursion (and even potential segfault)</span>
        <span class="n">call</span> <span class="o">=</span> <span class="n">_signature_get_user_defined_method</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="n">_signature_from_callable</span><span class="p">(</span>
                    <span class="n">call</span><span class="p">,</span>
                    <span class="n">follow_wrapper_chains</span><span class="o">=</span><span class="n">follow_wrapper_chains</span><span class="p">,</span>
                    <span class="n">skip_bound_arg</span><span class="o">=</span><span class="n">skip_bound_arg</span><span class="p">,</span>
                    <span class="n">sigcls</span><span class="o">=</span><span class="n">sigcls</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;no signature found for </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">ex</span>

    <span class="k">if</span> <span class="n">sig</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># For classes and objects we skip the first parameter of their</span>
        <span class="c1"># __call__, __new__, or __init__ methods</span>
        <span class="k">if</span> <span class="n">skip_bound_arg</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_signature_bound_method</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sig</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">BuiltinFunctionType</span><span class="p">):</span>
        <span class="c1"># Raise a nicer error message for builtins</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;no signature found for builtin function </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;callable </span><span class="si">{!r}</span><span class="s1"> is not supported by signature&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">_void</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A private marker - used in Parameter &amp; Signature.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">_empty</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Marker object for Signature.empty and Parameter.empty.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">_ParameterKind</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">IntEnum</span><span class="p">):</span>
    <span class="n">POSITIONAL_ONLY</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">POSITIONAL_OR_KEYWORD</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">VAR_POSITIONAL</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">KEYWORD_ONLY</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">VAR_KEYWORD</span> <span class="o">=</span> <span class="mi">4</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name_</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">description</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_PARAM_NAME_MAPPING</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>

<span class="n">_POSITIONAL_ONLY</span>         <span class="o">=</span> <span class="n">_ParameterKind</span><span class="o">.</span><span class="n">POSITIONAL_ONLY</span>
<span class="n">_POSITIONAL_OR_KEYWORD</span>   <span class="o">=</span> <span class="n">_ParameterKind</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span>
<span class="n">_VAR_POSITIONAL</span>          <span class="o">=</span> <span class="n">_ParameterKind</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span>
<span class="n">_KEYWORD_ONLY</span>            <span class="o">=</span> <span class="n">_ParameterKind</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span>
<span class="n">_VAR_KEYWORD</span>             <span class="o">=</span> <span class="n">_ParameterKind</span><span class="o">.</span><span class="n">VAR_KEYWORD</span>

<span class="n">_PARAM_NAME_MAPPING</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">_POSITIONAL_ONLY</span><span class="p">:</span> <span class="s1">&#39;positional-only&#39;</span><span class="p">,</span>
    <span class="n">_POSITIONAL_OR_KEYWORD</span><span class="p">:</span> <span class="s1">&#39;positional or keyword&#39;</span><span class="p">,</span>
    <span class="n">_VAR_POSITIONAL</span><span class="p">:</span> <span class="s1">&#39;variadic positional&#39;</span><span class="p">,</span>
    <span class="n">_KEYWORD_ONLY</span><span class="p">:</span> <span class="s1">&#39;keyword-only&#39;</span><span class="p">,</span>
    <span class="n">_VAR_KEYWORD</span><span class="p">:</span> <span class="s1">&#39;variadic keyword&#39;</span>
<span class="p">}</span>


<div class="viewcode-block" id="Parameter"><a class="viewcode-back" href="../api/generated/metpy.units.Parameter.html#metpy.units.Parameter">[docs]</a><span class="k">class</span> <span class="nc">Parameter</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Represents a parameter in a function signature.</span>

<span class="sd">    Has the following public attributes:</span>

<span class="sd">    * name : str</span>
<span class="sd">        The name of the parameter as a string.</span>
<span class="sd">    * default : object</span>
<span class="sd">        The default value for the parameter if specified.  If the</span>
<span class="sd">        parameter has no default value, this attribute is set to</span>
<span class="sd">        `Parameter.empty`.</span>
<span class="sd">    * annotation</span>
<span class="sd">        The annotation for the parameter if specified.  If the</span>
<span class="sd">        parameter has no annotation, this attribute is set to</span>
<span class="sd">        `Parameter.empty`.</span>
<span class="sd">    * kind : str</span>
<span class="sd">        Describes how argument values are bound to the parameter.</span>
<span class="sd">        Possible values: `Parameter.POSITIONAL_ONLY`,</span>
<span class="sd">        `Parameter.POSITIONAL_OR_KEYWORD`, `Parameter.VAR_POSITIONAL`,</span>
<span class="sd">        `Parameter.KEYWORD_ONLY`, `Parameter.VAR_KEYWORD`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_name&#39;</span><span class="p">,</span> <span class="s1">&#39;_kind&#39;</span><span class="p">,</span> <span class="s1">&#39;_default&#39;</span><span class="p">,</span> <span class="s1">&#39;_annotation&#39;</span><span class="p">)</span>

    <span class="n">POSITIONAL_ONLY</span>         <span class="o">=</span> <span class="n">_POSITIONAL_ONLY</span>
    <span class="n">POSITIONAL_OR_KEYWORD</span>   <span class="o">=</span> <span class="n">_POSITIONAL_OR_KEYWORD</span>
    <span class="n">VAR_POSITIONAL</span>          <span class="o">=</span> <span class="n">_VAR_POSITIONAL</span>
    <span class="n">KEYWORD_ONLY</span>            <span class="o">=</span> <span class="n">_KEYWORD_ONLY</span>
    <span class="n">VAR_KEYWORD</span>             <span class="o">=</span> <span class="n">_VAR_KEYWORD</span>

    <span class="n">empty</span> <span class="o">=</span> <span class="n">_empty</span>

<div class="viewcode-block" id="Parameter.__init__"><a class="viewcode-back" href="../api/generated/metpy.units.Parameter.html#metpy.units.Parameter.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">_empty</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">_empty</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kind</span> <span class="o">=</span> <span class="n">_ParameterKind</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;value </span><span class="si">{</span><span class="n">kind</span><span class="si">!r}</span><span class="s1"> is not a valid Parameter.kind&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_empty</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kind</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_VAR_POSITIONAL</span><span class="p">,</span> <span class="n">_VAR_KEYWORD</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> parameters cannot have default values&#39;</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_kind</span><span class="o">.</span><span class="n">description</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default</span> <span class="o">=</span> <span class="n">default</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_annotation</span> <span class="o">=</span> <span class="n">annotation</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="n">_empty</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;name is a required attribute for Parameter&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;name must be a str, not a </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span> <span class="ow">and</span> <span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="c1"># These are implicit arguments generated by comprehensions. In</span>
            <span class="c1"># order to provide a friendlier interface to users, we recast</span>
            <span class="c1"># their name as &quot;implicitN&quot; and treat them as positional-only.</span>
            <span class="c1"># See issue 19611.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kind</span> <span class="o">!=</span> <span class="n">_POSITIONAL_OR_KEYWORD</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s1">&#39;implicit arguments must be passed as &#39;</span>
                    <span class="s1">&#39;positional or keyword arguments, not </span><span class="si">{}</span><span class="s1">&#39;</span>
                <span class="p">)</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_kind</span><span class="o">.</span><span class="n">description</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kind</span> <span class="o">=</span> <span class="n">_POSITIONAL_ONLY</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;implicit</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">isidentifier</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{!r}</span><span class="s1"> is not a valid parameter name&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span></div>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kind</span><span class="p">),</span>
                <span class="p">{</span><span class="s1">&#39;_default&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default</span><span class="p">,</span>
                 <span class="s1">&#39;_annotation&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotation</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;_default&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_annotation</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;_annotation&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">default</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">annotation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotation</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kind</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kind</span>

<div class="viewcode-block" id="Parameter.replace"><a class="viewcode-back" href="../api/generated/metpy.units.Parameter.html#metpy.units.Parameter.replace">[docs]</a>    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">_void</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">_void</span><span class="p">,</span>
                <span class="n">annotation</span><span class="o">=</span><span class="n">_void</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">_void</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a customized copy of the Parameter.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="n">_void</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

        <span class="k">if</span> <span class="n">kind</span> <span class="ow">is</span> <span class="n">_void</span><span class="p">:</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kind</span>

        <span class="k">if</span> <span class="n">annotation</span> <span class="ow">is</span> <span class="n">_void</span><span class="p">:</span>
            <span class="n">annotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotation</span>

        <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="n">_void</span><span class="p">:</span>
            <span class="n">default</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default</span>

        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">name</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">annotation</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span>
        <span class="n">formatted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

        <span class="c1"># Add annotation and default value</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_empty</span><span class="p">:</span>
            <span class="n">formatted</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">formatted</span><span class="p">,</span>
                                       <span class="n">formatannotation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_annotation</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_empty</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_empty</span><span class="p">:</span>
                <span class="n">formatted</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">formatted</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_default</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">formatted</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">formatted</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_default</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">_VAR_POSITIONAL</span><span class="p">:</span>
            <span class="n">formatted</span> <span class="o">=</span> <span class="s1">&#39;*&#39;</span> <span class="o">+</span> <span class="n">formatted</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">_VAR_KEYWORD</span><span class="p">:</span>
            <span class="n">formatted</span> <span class="o">=</span> <span class="s1">&#39;**&#39;</span> <span class="o">+</span> <span class="n">formatted</span>

        <span class="k">return</span> <span class="n">formatted</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;</span><span class="si">{}</span><span class="s1"> &quot;</span><span class="si">{}</span><span class="s1">&quot;&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_name</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_kind</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_kind</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_default</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_default</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_annotation</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_annotation</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">BoundArguments</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Result of `Signature.bind` call.  Holds the mapping of arguments</span>
<span class="sd">    to the function&#39;s parameters.</span>

<span class="sd">    Has the following public attributes:</span>

<span class="sd">    * arguments : OrderedDict</span>
<span class="sd">        An ordered mutable mapping of parameters&#39; names to arguments&#39; values.</span>
<span class="sd">        Does not contain arguments&#39; default values.</span>
<span class="sd">    * signature : Signature</span>
<span class="sd">        The Signature object that created this instance.</span>
<span class="sd">    * args : tuple</span>
<span class="sd">        Tuple of positional arguments values.</span>
<span class="sd">    * kwargs : dict</span>
<span class="sd">        Dict of keyword arguments values.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;arguments&#39;</span><span class="p">,</span> <span class="s1">&#39;_signature&#39;</span><span class="p">,</span> <span class="s1">&#39;__weakref__&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signature</span><span class="p">,</span> <span class="n">arguments</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span> <span class="o">=</span> <span class="n">arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_signature</span> <span class="o">=</span> <span class="n">signature</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">signature</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_signature</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_signature</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_VAR_KEYWORD</span><span class="p">,</span> <span class="n">_KEYWORD_ONLY</span><span class="p">):</span>
                <span class="k">break</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">arg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># We&#39;re done here. Other arguments</span>
                <span class="c1"># will be mapped in &#39;BoundArguments.kwargs&#39;</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">_VAR_POSITIONAL</span><span class="p">:</span>
                    <span class="c1"># *args</span>
                    <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># plain argument</span>
                    <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">kwargs_started</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_signature</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">kwargs_started</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_VAR_KEYWORD</span><span class="p">,</span> <span class="n">_KEYWORD_ONLY</span><span class="p">):</span>
                    <span class="n">kwargs_started</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">param_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span><span class="p">:</span>
                        <span class="n">kwargs_started</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">continue</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">kwargs_started</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">arg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">_VAR_KEYWORD</span><span class="p">:</span>
                    <span class="c1"># **kwargs</span>
                    <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># plain keyword argument</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg</span>

        <span class="k">return</span> <span class="n">kwargs</span>

    <span class="k">def</span> <span class="nf">apply_defaults</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set default values for missing arguments.</span>

<span class="sd">        For variable-positional arguments (*args) the default is an</span>
<span class="sd">        empty tuple.</span>

<span class="sd">        For variable-keyword arguments (**kwargs) the default is an</span>
<span class="sd">        empty dict.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arguments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span>
        <span class="n">new_arguments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_signature</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">new_arguments</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">arguments</span><span class="p">[</span><span class="n">name</span><span class="p">]))</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_empty</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span>
                <span class="k">elif</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="ow">is</span> <span class="n">_VAR_POSITIONAL</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="p">()</span>
                <span class="k">elif</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="ow">is</span> <span class="n">_VAR_KEYWORD</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># This BoundArguments was likely produced by</span>
                    <span class="c1"># Signature.bind_partial().</span>
                    <span class="k">continue</span>
                <span class="n">new_arguments</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="n">new_arguments</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BoundArguments</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">signature</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">signature</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">arguments</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_signature</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;_signature&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;arguments&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;_signature&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_signature</span><span class="p">,</span> <span class="s1">&#39;arguments&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">=</span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;</span><span class="si">{}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1">)&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">Signature</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A Signature object represents the overall signature of a function.</span>
<span class="sd">    It stores a Parameter object for each parameter accepted by the</span>
<span class="sd">    function, as well as information specific to the function itself.</span>

<span class="sd">    A Signature object has the following public attributes and methods:</span>

<span class="sd">    * parameters : OrderedDict</span>
<span class="sd">        An ordered mapping of parameters&#39; names to the corresponding</span>
<span class="sd">        Parameter objects (keyword-only arguments are in the same order</span>
<span class="sd">        as listed in `code.co_varnames`).</span>
<span class="sd">    * return_annotation : object</span>
<span class="sd">        The annotation for the return type of the function if specified.</span>
<span class="sd">        If the function has no annotation for its return type, this</span>
<span class="sd">        attribute is set to `Signature.empty`.</span>
<span class="sd">    * bind(*args, **kwargs) -&gt; BoundArguments</span>
<span class="sd">        Creates a mapping from positional and keyword arguments to</span>
<span class="sd">        parameters.</span>
<span class="sd">    * bind_partial(*args, **kwargs) -&gt; BoundArguments</span>
<span class="sd">        Creates a partial mapping from positional and keyword arguments</span>
<span class="sd">        to parameters (simulating &#39;functools.partial&#39; behavior.)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_return_annotation&#39;</span><span class="p">,</span> <span class="s1">&#39;_parameters&#39;</span><span class="p">)</span>

    <span class="n">_parameter_cls</span> <span class="o">=</span> <span class="n">Parameter</span>
    <span class="n">_bound_arguments_cls</span> <span class="o">=</span> <span class="n">BoundArguments</span>

    <span class="n">empty</span> <span class="o">=</span> <span class="n">_empty</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">_empty</span><span class="p">,</span>
                 <span class="n">__validate_parameters__</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructs Signature from the given list of Parameter</span>
<span class="sd">        objects and &#39;return_annotation&#39;.  All arguments are optional.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">__validate_parameters__</span><span class="p">:</span>
                <span class="n">params</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                <span class="n">top_kind</span> <span class="o">=</span> <span class="n">_POSITIONAL_ONLY</span>
                <span class="n">kind_defaults</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
                    <span class="n">kind</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span>

                    <span class="k">if</span> <span class="n">kind</span> <span class="o">&lt;</span> <span class="n">top_kind</span><span class="p">:</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="s1">&#39;wrong parameter order: </span><span class="si">{}</span><span class="s1"> parameter before </span><span class="si">{}</span><span class="s1"> &#39;</span>
                            <span class="s1">&#39;parameter&#39;</span>
                        <span class="p">)</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">top_kind</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
                                         <span class="n">kind</span><span class="o">.</span><span class="n">description</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">kind</span> <span class="o">&gt;</span> <span class="n">top_kind</span><span class="p">:</span>
                        <span class="n">kind_defaults</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="n">top_kind</span> <span class="o">=</span> <span class="n">kind</span>

                    <span class="k">if</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_POSITIONAL_ONLY</span><span class="p">,</span> <span class="n">_POSITIONAL_OR_KEYWORD</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="n">_empty</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">kind_defaults</span><span class="p">:</span>
                                <span class="c1"># No default for this parameter, but the</span>
                                <span class="c1"># previous parameter of the same kind had</span>
                                <span class="c1"># a default</span>
                                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;non-default argument follows default &#39;</span> \
                                      <span class="s1">&#39;argument&#39;</span>
                                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># There is a default for this parameter.</span>
                            <span class="n">kind_defaults</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;duplicate parameter name: </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                    <span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">params</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(((</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
                                                <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">MappingProxyType</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return_annotation</span> <span class="o">=</span> <span class="n">return_annotation</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_function</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructs Signature for the given python function.</span>

<span class="sd">        Deprecated since Python 3.5, use `Signature.from_callable()`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;inspect.Signature.from_function() is deprecated since &quot;</span>
                      <span class="s2">&quot;Python 3.5, use Signature.from_callable()&quot;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_signature_from_function</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_builtin</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructs Signature for the given builtin function.</span>

<span class="sd">        Deprecated since Python 3.5, use `Signature.from_callable()`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;inspect.Signature.from_builtin() is deprecated since &quot;</span>
                      <span class="s2">&quot;Python 3.5, use Signature.from_callable()&quot;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_signature_from_builtin</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_callable</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">follow_wrapped</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructs Signature for the given callable object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_signature_from_callable</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">sigcls</span><span class="o">=</span><span class="bp">cls</span><span class="p">,</span>
                                        <span class="n">follow_wrapper_chains</span><span class="o">=</span><span class="n">follow_wrapped</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">return_annotation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_return_annotation</span>

    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">parameters</span><span class="o">=</span><span class="n">_void</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">_void</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a customized copy of the Signature.</span>
<span class="sd">        Pass &#39;parameters&#39; and/or &#39;return_annotation&#39; arguments</span>
<span class="sd">        to override them in the new copy.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">parameters</span> <span class="ow">is</span> <span class="n">_void</span><span class="p">:</span>
            <span class="n">parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">return_annotation</span> <span class="ow">is</span> <span class="n">_void</span><span class="p">:</span>
            <span class="n">return_annotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_return_annotation</span>

        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">parameters</span><span class="p">,</span>
                          <span class="n">return_annotation</span><span class="o">=</span><span class="n">return_annotation</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_hash_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">params</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">param</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                             <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="n">_KEYWORD_ONLY</span><span class="p">)</span>

        <span class="n">kwo_params</span> <span class="o">=</span> <span class="p">{</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">param</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                                        <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">_KEYWORD_ONLY</span><span class="p">}</span>

        <span class="k">return</span> <span class="n">params</span><span class="p">,</span> <span class="n">kwo_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_annotation</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">kwo_params</span><span class="p">,</span> <span class="n">return_annotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash_basis</span><span class="p">()</span>
        <span class="n">kwo_params</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">kwo_params</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="n">params</span><span class="p">,</span> <span class="n">kwo_params</span><span class="p">,</span> <span class="n">return_annotation</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Signature</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash_basis</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_hash_basis</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Private method. Don&#39;t use directly.&quot;&quot;&quot;</span>

        <span class="n">arguments</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="n">parameters</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">parameters_ex</span> <span class="o">=</span> <span class="p">()</span>
        <span class="n">arg_vals</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Let&#39;s iterate through the positional arguments and corresponding</span>
            <span class="c1"># parameters</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">arg_val</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">arg_vals</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="c1"># No more positional arguments</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">param</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                    <span class="c1"># No more parameters. That&#39;s it. Just need to check that</span>
                    <span class="c1"># we have no `kwargs` after this while loop</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">_VAR_POSITIONAL</span><span class="p">:</span>
                        <span class="c1"># That&#39;s OK, just empty *args.  Let&#39;s start parsing</span>
                        <span class="c1"># kwargs</span>
                        <span class="k">break</span>
                    <span class="k">elif</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">_POSITIONAL_ONLY</span><span class="p">:</span>
                            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{arg!r}</span><span class="s1"> parameter is positional only, &#39;</span> \
                                  <span class="s1">&#39;but was passed as a keyword&#39;</span>
                            <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">arg</span><span class="o">=</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>
                        <span class="n">parameters_ex</span> <span class="o">=</span> <span class="p">(</span><span class="n">param</span><span class="p">,)</span>
                        <span class="k">break</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">_VAR_KEYWORD</span> <span class="ow">or</span>
                                                <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_empty</span><span class="p">):</span>
                        <span class="c1"># That&#39;s fine too - we have a default value for this</span>
                        <span class="c1"># parameter.  So, lets start parsing `kwargs`, starting</span>
                        <span class="c1"># with the current parameter</span>
                        <span class="n">parameters_ex</span> <span class="o">=</span> <span class="p">(</span><span class="n">param</span><span class="p">,)</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># No default, not VAR_KEYWORD, not VAR_POSITIONAL,</span>
                        <span class="c1"># not in `kwargs`</span>
                        <span class="k">if</span> <span class="n">partial</span><span class="p">:</span>
                            <span class="n">parameters_ex</span> <span class="o">=</span> <span class="p">(</span><span class="n">param</span><span class="p">,)</span>
                            <span class="k">break</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;missing a required argument: </span><span class="si">{arg!r}</span><span class="s1">&#39;</span>
                            <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">arg</span><span class="o">=</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># We have a positional argument to process</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">param</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;too many positional arguments&#39;</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_VAR_KEYWORD</span><span class="p">,</span> <span class="n">_KEYWORD_ONLY</span><span class="p">):</span>
                        <span class="c1"># Looks like we have no parameter for this positional</span>
                        <span class="c1"># argument</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="s1">&#39;too many positional arguments&#39;</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

                    <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">_VAR_POSITIONAL</span><span class="p">:</span>
                        <span class="c1"># We have an &#39;*args&#39;-like argument, let&#39;s fill it with</span>
                        <span class="c1"># all positional arguments we have left and move on to</span>
                        <span class="c1"># the next phase</span>
                        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">arg_val</span><span class="p">]</span>
                        <span class="n">values</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">arg_vals</span><span class="p">)</span>
                        <span class="n">arguments</span><span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
                        <span class="k">break</span>

                    <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="n">_POSITIONAL_ONLY</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="s1">&#39;multiple values for argument </span><span class="si">{arg!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">arg</span><span class="o">=</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">))</span> <span class="kn">from</span> <span class="bp">None</span>

                    <span class="n">arguments</span><span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg_val</span>

        <span class="c1"># Now, we iterate through the remaining parameters to process</span>
        <span class="c1"># keyword arguments</span>
        <span class="n">kwargs_param</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">parameters_ex</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">_VAR_KEYWORD</span><span class="p">:</span>
                <span class="c1"># Memorize that we have a &#39;**kwargs&#39;-like parameter</span>
                <span class="n">kwargs_param</span> <span class="o">=</span> <span class="n">param</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">_VAR_POSITIONAL</span><span class="p">:</span>
                <span class="c1"># Named arguments don&#39;t refer to &#39;*args&#39;-like parameters.</span>
                <span class="c1"># We only arrive here if the positional arguments ended</span>
                <span class="c1"># before reaching the last parameter before *args.</span>
                <span class="k">continue</span>

            <span class="n">param_name</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">arg_val</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">param_name</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># We have no value for this parameter.  It&#39;s fine though,</span>
                <span class="c1"># if it has a default value, or it is an &#39;*args&#39;-like</span>
                <span class="c1"># parameter, left alone by the processing of positional</span>
                <span class="c1"># arguments.</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">partial</span> <span class="ow">and</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="n">_VAR_POSITIONAL</span> <span class="ow">and</span>
                                                    <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="n">_empty</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;missing a required argument: </span><span class="si">{arg!r}</span><span class="s1">&#39;</span><span class="o">.</span> \
                                    <span class="nb">format</span><span class="p">(</span><span class="n">arg</span><span class="o">=</span><span class="n">param_name</span><span class="p">))</span> <span class="kn">from</span> <span class="bp">None</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">_POSITIONAL_ONLY</span><span class="p">:</span>
                    <span class="c1"># This should never happen in case of a properly built</span>
                    <span class="c1"># Signature object (but let&#39;s have this check here</span>
                    <span class="c1"># to ensure correct behaviour just in case)</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{arg!r}</span><span class="s1"> parameter is positional only, &#39;</span>
                                    <span class="s1">&#39;but was passed as a keyword&#39;</span><span class="o">.</span> \
                                    <span class="nb">format</span><span class="p">(</span><span class="n">arg</span><span class="o">=</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

                <span class="n">arguments</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg_val</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwargs_param</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Process our &#39;**kwargs&#39;-like parameter</span>
                <span class="n">arguments</span><span class="p">[</span><span class="n">kwargs_param</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s1">&#39;got an unexpected keyword argument </span><span class="si">{arg!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">arg</span><span class="o">=</span><span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bound_arguments_cls</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arguments</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a BoundArguments object, that maps the passed `args`</span>
<span class="sd">        and `kwargs` to the function&#39;s signature.  Raises `TypeError`</span>
<span class="sd">        if the passed arguments can not be bound.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bind</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bind_partial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a BoundArguments object, that partially maps the</span>
<span class="sd">        passed `args` and `kwargs` to the function&#39;s signature.</span>
<span class="sd">        Raises `TypeError` if the passed arguments can not be bound.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bind</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
                <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="o">.</span><span class="n">values</span><span class="p">()),),</span>
                <span class="p">{</span><span class="s1">&#39;_return_annotation&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_return_annotation</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return_annotation</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;_return_annotation&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">render_pos_only_separator</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">render_kw_only_separator</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">formatted</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>

            <span class="n">kind</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span>

            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">_POSITIONAL_ONLY</span><span class="p">:</span>
                <span class="n">render_pos_only_separator</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">render_pos_only_separator</span><span class="p">:</span>
                <span class="c1"># It&#39;s not a positional-only parameter, and the flag</span>
                <span class="c1"># is set to &#39;True&#39; (there were pos-only params before.)</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
                <span class="n">render_pos_only_separator</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">_VAR_POSITIONAL</span><span class="p">:</span>
                <span class="c1"># OK, we have an &#39;*args&#39;-like parameter, so we won&#39;t need</span>
                <span class="c1"># a &#39;*&#39; to separate keyword-only arguments</span>
                <span class="n">render_kw_only_separator</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">_KEYWORD_ONLY</span> <span class="ow">and</span> <span class="n">render_kw_only_separator</span><span class="p">:</span>
                <span class="c1"># We have a keyword-only parameter to render and we haven&#39;t</span>
                <span class="c1"># rendered an &#39;*args&#39;-like parameter before, so add a &#39;*&#39;</span>
                <span class="c1"># separator to the parameters list (&quot;foo(arg1, *, arg2)&quot; case)</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>
                <span class="c1"># This condition should be only triggered once, so</span>
                <span class="c1"># reset the flag</span>
                <span class="n">render_kw_only_separator</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">formatted</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">render_pos_only_separator</span><span class="p">:</span>
            <span class="c1"># There were only positional-only parameters, hence the</span>
            <span class="c1"># flag was not reset to &#39;False&#39;</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>

        <span class="n">rendered</span> <span class="o">=</span> <span class="s1">&#39;(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_annotation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_empty</span><span class="p">:</span>
            <span class="n">anno</span> <span class="o">=</span> <span class="n">formatannotation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">return_annotation</span><span class="p">)</span>
            <span class="n">rendered</span> <span class="o">+=</span> <span class="s1">&#39; -&gt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">anno</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rendered</span>


<div class="viewcode-block" id="signature"><a class="viewcode-back" href="../api/generated/metpy.units.signature.html#metpy.units.signature">[docs]</a><span class="k">def</span> <span class="nf">signature</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">follow_wrapped</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get a signature object for the passed callable.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Signature</span><span class="o">.</span><span class="n">from_callable</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">follow_wrapped</span><span class="o">=</span><span class="n">follow_wrapped</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_main</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Logic for inspecting an object given at command line &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">argparse</span>
    <span class="kn">import</span> <span class="nn">importlib</span>

    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s1">&#39;object&#39;</span><span class="p">,</span>
         <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The object to be analysed. &quot;</span>
              <span class="s2">&quot;It supports the &#39;module:qualname&#39; syntax&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s1">&#39;-d&#39;</span><span class="p">,</span> <span class="s1">&#39;--details&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Display info about the module rather than its source code&#39;</span><span class="p">)</span>

    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>

    <span class="n">target</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">object</span>
    <span class="n">mod_name</span><span class="p">,</span> <span class="n">has_attrs</span><span class="p">,</span> <span class="n">attrs</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">mod_name</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Failed to import </span><span class="si">{}</span><span class="s2"> (</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mod_name</span><span class="p">,</span>
                                                    <span class="nb">type</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                                    <span class="n">exc</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">has_attrs</span><span class="p">:</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">attrs</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">module</span>
        <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">part</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">module</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">builtin_module_names</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can&#39;t get info for builtin modules.&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">details</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Target: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Origin: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">getsourcefile</span><span class="p">(</span><span class="n">module</span><span class="p">)))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Cached: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">__cached__</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="n">module</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Loader: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">__loader__</span><span class="p">)))</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="s1">&#39;__path__&#39;</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Submodule search path: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">__path__</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">__</span><span class="p">,</span> <span class="n">lineno</span> <span class="o">=</span> <span class="n">findsource</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Line: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lineno</span><span class="p">))</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">getsource</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">_main</span><span class="p">()</span>
</pre></div>

              </div>
              
              
              <div class='prev-next-bottom'>
                

              </div>
              
          </main>
          

      </div>
    </div>

    
  <script src="../_static/js/index.d3f166471bb80abb5163.js"></script>


    
    <!-- Google Analytics -->
    <script>
      window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
      ga('create', 'UA-92978945-1', 'auto');
      ga('set', 'anonymizeIp', true);
      ga('send', 'pageview');
    </script>
    <script async src='https://www.google-analytics.com/analytics.js'></script>
    <!-- End Google Analytics -->
    <footer class="footer mt-5 mt-md-0">
  <div class="container">
    <p>
          &copy; Copyright 2008â€“2021, MetPy Developers. Development supported by National Science Foundation grants AGS-1344155, OAC-1740315, and AGS-1901712.<br/>
        Last updated on Mar 09, 2021 at 18:02:48.<br/>
        Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.5.2.<br/>
    </p>
  </div>
</footer>
  </body>
</html>